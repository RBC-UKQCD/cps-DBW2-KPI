/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#include <alg/hmd_arg.h>
CPS_START_NAMESPACE

bool_t
vml_FRatVec (VML *vmls, char *name,FRatVec objp)
{
	if (!vml_vector (vmls,name,(char *)objp,MAX_RAT_DEGREE,sizeof(Float),(vmlproc_t)vml_Float))
		return FALSE;
	return TRUE;
}

bool_t
vml_IMassVec (VML *vmls, char *name,IMassVec objp)
{
	if (!vml_vector (vmls,name,(char *)objp,MAX_HMD_MASSES,sizeof(int),(vmlproc_t)vml_int))
		return FALSE;
	return TRUE;
}

bool_t
vml_FMassVec (VML *vmls, char *name,FMassVec objp)
{
	if (!vml_vector (vmls,name,(char *)objp,MAX_HMD_MASSES,sizeof(Float),(vmlproc_t)vml_Float))
		return FALSE;
	return TRUE;
}

bool_t
vml_FRatMassVec (VML *vmls, char *name,FRatMassVec objp)
{
	if (!vml_vector (vmls,name,(char *)objp,MAX_HMD_MASSES,sizeof(FRatVec),(vmlproc_t)vml_FRatVec))
		return FALSE;
	return TRUE;
}
	 bool HmdArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool HmdArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool HmdArg::Vml(VML *vmls,char *instance){
		 if(!vml_HmdArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_HmdArg (VML *vmls, char *name,HmdArg *objp)
{
	 vml_class_begin(vmls,"HmdArg",name);
	int i;
	 if (!vml_int (vmls, "n_frm_masses", &objp->n_frm_masses))
		 return FALSE;
	 if (!vml_int (vmls, "n_bsn_masses", &objp->n_bsn_masses))
		 return FALSE;
	 if (!vml_int (vmls, "steps_per_traj", &objp->steps_per_traj))
		 return FALSE;
	 if (!vml_Float (vmls, "step_size", &objp->step_size))
		 return FALSE;
	 if (!vml_MetropolisType (vmls, "metropolis", &objp->metropolis))
		 return FALSE;
	 if (!vml_ReunitarizeType (vmls, "reunitarize", &objp->reunitarize))
		 return FALSE;
	 if (!vml_RatApproxType (vmls, "approx_type", &objp->approx_type))
		 return FALSE;
	 if (!vml_Float (vmls, "spread", &objp->spread))
		 return FALSE;
	 if (!vml_long (vmls, "precision", &objp->precision))
		 return FALSE;
	 if (!vml_int (vmls, "isz", &objp->isz))
		 return FALSE;
	 if (!vml_int (vmls, "sw", &objp->sw))
		 return FALSE;
	 if (!vml_int (vmls, "chrono", &objp->chrono))
		 return FALSE;
	 if (!vml_int (vmls, "reproduce", &objp->reproduce))
		 return FALSE;
	 if (!vml_int (vmls, "reproduce_attempt_limit", &objp->reproduce_attempt_limit))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "frm_mass", objp->frm_mass))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "frm_flavors", objp->frm_flavors))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "bsn_mass", objp->bsn_mass))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "max_num_iter", objp->max_num_iter))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "stop_rsd", objp->stop_rsd))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "stop_rsd_md", objp->stop_rsd_md))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "stop_rsd_mc", objp->stop_rsd_mc))
		 return FALSE;
	 if (!vml_vector (vmls, "field_type", (char *)objp->field_type, MAX_HMD_MASSES,
		sizeof (FieldType), (vmlproc_t) vml_FieldType))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "valid_approx", objp->valid_approx))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "lambda_low", objp->lambda_low))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "lambda_high", objp->lambda_high))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "lambda_min", objp->lambda_min))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "lambda_max", objp->lambda_max))
		 return FALSE;
	 if (!vml_RhmcPolesAction (vmls, "rhmc_poles_action", &objp->rhmc_poles_action))
		 return FALSE;
	 if (!vml_string (vmls, "rhmc_poles_file", &objp->rhmc_poles_file, ~0))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "frm_power_num", objp->frm_power_num))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "frm_power_den", objp->frm_power_den))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "FRatDeg", objp->FRatDeg))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "FRatDegNew", objp->FRatDegNew))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "SRatDegNew", objp->SRatDegNew))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "FRatError", objp->FRatError))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "FRatNorm", objp->FRatNorm))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "FRatRes", objp->FRatRes))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "FRatPole", objp->FRatPole))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "SRatDeg", objp->SRatDeg))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "SRatError", objp->SRatError))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "SRatNorm", objp->SRatNorm))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "SRatRes", objp->SRatRes))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "SRatPole", objp->SRatPole))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "SIRatNorm", objp->SIRatNorm))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "SIRatRes", objp->SIRatRes))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "SIRatPole", objp->SIRatPole))
		 return FALSE;
	 vml_class_end(vmls,"HmdArg",name);
	return TRUE;
}
	 bool EvoArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool EvoArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool EvoArg::Vml(VML *vmls,char *instance){
		 if(!vml_EvoArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_EvoArg (VML *vmls, char *name,EvoArg *objp)
{
	 vml_class_begin(vmls,"EvoArg",name);
	 if (!vml_int (vmls, "traj_start", &objp->traj_start))
		 return FALSE;
	 if (!vml_int (vmls, "gauge_unload_period", &objp->gauge_unload_period))
		 return FALSE;
	 if (!vml_int (vmls, "gauge_configurations", &objp->gauge_configurations))
		 return FALSE;
	 if (!vml_int (vmls, "io_concurrency", &objp->io_concurrency))
		 return FALSE;
	 if (!vml_int (vmls, "hdw_xcsum", &objp->hdw_xcsum))
		 return FALSE;
	 if (!vml_int (vmls, "hdw_rcsum", &objp->hdw_rcsum))
		 return FALSE;
	 if (!vml_int (vmls, "reproduce_interval", &objp->reproduce_interval))
		 return FALSE;
	 if (!vml_string (vmls, "ensemble_id", &objp->ensemble_id, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "ensemble_label", &objp->ensemble_label, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "creator", &objp->creator, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "gauge_file_stem", &objp->gauge_file_stem, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "rng_file_stem", &objp->rng_file_stem, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "plaquette_stem", &objp->plaquette_stem, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "pbp_stem", &objp->pbp_stem, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "evo_stem", &objp->evo_stem, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "w_spect_directory", &objp->w_spect_directory, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "work_directory", &objp->work_directory, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "measure_pbp", &objp->measure_pbp))
		 return FALSE;
	 if (!vml_int (vmls, "measure_w_spect_interval", &objp->measure_w_spect_interval))
		 return FALSE;
	 vml_class_end(vmls,"EvoArg",name);
	return TRUE;
}
	 bool RhmcPolesState::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool RhmcPolesState::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool RhmcPolesState::Vml(VML *vmls,char *instance){
		 if(!vml_RhmcPolesState(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_RhmcPolesState (VML *vmls, char *name,RhmcPolesState *objp)
{
	 vml_class_begin(vmls,"RhmcPolesState",name);
	 if (!vml_IMassVec (vmls, "frm_power_num", objp->frm_power_num))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "frm_power_den", objp->frm_power_den))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "FRatDeg", objp->FRatDeg))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "FRatDegNew", objp->FRatDegNew))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "SRatDegNew", objp->SRatDegNew))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "FRatError", objp->FRatError))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "FRatNorm", objp->FRatNorm))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "FRatRes", objp->FRatRes))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "FRatPole", objp->FRatPole))
		 return FALSE;
	 if (!vml_IMassVec (vmls, "SRatDeg", objp->SRatDeg))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "SRatError", objp->SRatError))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "SRatNorm", objp->SRatNorm))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "SRatRes", objp->SRatRes))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "SRatPole", objp->SRatPole))
		 return FALSE;
	 if (!vml_FMassVec (vmls, "SIRatNorm", objp->SIRatNorm))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "SIRatRes", objp->SIRatRes))
		 return FALSE;
	 if (!vml_FRatMassVec (vmls, "SIRatPole", objp->SIRatPole))
		 return FALSE;
	 vml_class_end(vmls,"RhmcPolesState",name);
	return TRUE;
}
CPS_END_NAMESPACE
