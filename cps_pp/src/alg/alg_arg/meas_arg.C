/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#include <alg/meas_arg.h>
CPS_START_NAMESPACE

bool_t
vml_MeasLimits (VML *vmls, char *name,MeasLimits *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,MeasLimits_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map MeasLimits_map[] = {
	{"MeasLimits","MAX_MEAS_TASK",MAX_MEAS_TASK},
	{NULL,NULL,0}
};

bool_t
vml_MeasType (VML *vmls, char *name,MeasType *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,MeasType_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map MeasType_map[] = {
	{"MeasType","MeasAlgPlaq",MeasAlgPlaq},
	{"MeasType","MeasAlgPbp",MeasAlgPbp},
	{"MeasType","MeasAlgWspect",MeasAlgWspect},
	{"MeasType","MeasAlgEig",MeasAlgEig},
	{"MeasType","MeasAlgPot",MeasAlgPot},
	{"MeasType","MeasAlgFixGauge",MeasAlgFixGauge},
	{"MeasType","MeasAlgFixGaugeFree",MeasAlgFixGaugeFree},
	{"MeasType","MeasAlgQPropW",MeasAlgQPropW},
	{"MeasType","MeasAlgNuc3pt",MeasAlgNuc3pt},
	{"MeasType","MeasAlgRandomGauge",MeasAlgRandomGauge},
	{NULL,NULL,0}
};

bool_t
vml_MeasIOTask (VML *vmls, char *name,MeasIOTask *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,MeasIOTask_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map MeasIOTask_map[] = {
	{"MeasIOTask","MeasIOLoad",MeasIOLoad},
	{"MeasIOTask","MeasIOSave",MeasIOSave},
	{"MeasIOTask","MeasIONone",MeasIONone},
	{NULL,NULL,0}
};
	 bool MeasTask::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool MeasTask::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool MeasTask::Vml(VML *vmls,char *instance){
		 if(!vml_MeasTask(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_MeasTask (VML *vmls, char *name,MeasTask *objp)
{
	 vml_class_begin(vmls,"MeasTask",name);
	 if (!vml_MeasType (vmls, "Measurement", &objp->Measurement))
		 return FALSE;
	 if (!vml_string (vmls, "ArgFilename", &objp->ArgFilename, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "OutputFilestem", &objp->OutputFilestem, ~0))
		 return FALSE;
	 vml_class_end(vmls,"MeasTask",name);
	return TRUE;
}
	 bool MeasArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool MeasArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool MeasArg::Vml(VML *vmls,char *instance){
		 if(!vml_MeasArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_MeasArg (VML *vmls, char *name,MeasArg *objp)
{
	 vml_class_begin(vmls,"MeasArg",name);
	 if (!vml_FclassType (vmls, "Fermion", &objp->Fermion))
		 return FALSE;
	 if (!vml_GclassType (vmls, "Gluon", &objp->Gluon))
		 return FALSE;
	 if (!vml_string (vmls, "WorkDirectory", &objp->WorkDirectory, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "GaugeStem", &objp->GaugeStem, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "RNGStem", &objp->RNGStem, ~0))
		 return FALSE;
	 if (!vml_MeasIOTask (vmls, "GaugeIO", &objp->GaugeIO))
		 return FALSE;
	 if (!vml_MeasIOTask (vmls, "RNGIO", &objp->RNGIO))
		 return FALSE;
	 if (!vml_int (vmls, "TrajStart", &objp->TrajStart))
		 return FALSE;
	 if (!vml_int (vmls, "TrajIncrement", &objp->TrajIncrement))
		 return FALSE;
	 if (!vml_int (vmls, "TrajLessThanLimit", &objp->TrajLessThanLimit))
		 return FALSE;
	 if (!vml_int (vmls, "TrajCur", &objp->TrajCur))
		 return FALSE;
	 if (!vml_int (vmls, "HdwXCsum", &objp->HdwXCsum))
		 return FALSE;
	 if (!vml_int (vmls, "HdwRCsum", &objp->HdwRCsum))
		 return FALSE;
	 if (!vml_int (vmls, "IOconcurrency", &objp->IOconcurrency))
		 return FALSE;
	 if (!vml_array (vmls, "TaskList", (char **)&objp->TaskList.TaskList_val, (u_int *) &objp->TaskList.TaskList_len, ~0,
		sizeof (MeasTask), (vmlproc_t) vml_MeasTask))
		 return FALSE;
	 vml_class_end(vmls,"MeasArg",name);
	return TRUE;
}
CPS_END_NAMESPACE
