/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#include <alg/int_arg.h>
CPS_START_NAMESPACE
	 bool IntABArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool IntABArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool IntABArg::Vml(VML *vmls,char *instance){
		 if(!vml_IntABArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_IntABArg (VML *vmls, char *name,IntABArg *objp)
{
	 vml_class_begin(vmls,"IntABArg",name);
	 if (!vml_IntegratorType (vmls, "type", &objp->type))
		 return FALSE;
	 if (!vml_int (vmls, "A_steps", &objp->A_steps))
		 return FALSE;
	 if (!vml_int (vmls, "B_steps", &objp->B_steps))
		 return FALSE;
	 if (!vml_IntegratorLevel (vmls, "level", &objp->level))
		 return FALSE;
	 if (!vml_Float (vmls, "lambda", &objp->lambda))
		 return FALSE;
	 vml_class_end(vmls,"IntABArg",name);
	return TRUE;
}
	 bool ActionArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool ActionArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool ActionArg::Vml(VML *vmls,char *instance){
		 if(!vml_ActionArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_ActionArg (VML *vmls, char *name,ActionArg *objp)
{
	 vml_class_begin(vmls,"ActionArg",name);
	 if (!vml_ForceMeasure (vmls, "force_measure", &objp->force_measure))
		 return FALSE;
	 if (!vml_string (vmls, "force_label", &objp->force_label, ~0))
		 return FALSE;
	 vml_class_end(vmls,"ActionArg",name);
	return TRUE;
}
	 bool BilinearDescr::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool BilinearDescr::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool BilinearDescr::Vml(VML *vmls,char *instance){
		 if(!vml_BilinearDescr(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_BilinearDescr (VML *vmls, char *name,BilinearDescr *objp)
{
	 vml_class_begin(vmls,"BilinearDescr",name);
	 if (!vml_Float (vmls, "mass", &objp->mass))
		 return FALSE;
	 if (!vml_int (vmls, "max_num_iter", &objp->max_num_iter))
		 return FALSE;
	 vml_class_end(vmls,"BilinearDescr",name);
	return TRUE;
}
	 bool ActionBilinearArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool ActionBilinearArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool ActionBilinearArg::Vml(VML *vmls,char *instance){
		 if(!vml_ActionBilinearArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_ActionBilinearArg (VML *vmls, char *name,ActionBilinearArg *objp)
{
	 vml_class_begin(vmls,"ActionBilinearArg",name);
	 if (!vml_FclassType (vmls, "fermion", &objp->fermion))
		 return FALSE;
	 if (!vml_array (vmls, "bilinears", (char **)&objp->bilinears.bilinears_val, (u_int *) &objp->bilinears.bilinears_len, ~0,
		sizeof (BilinearDescr), (vmlproc_t) vml_BilinearDescr))
		 return FALSE;
	 if (!vml_ActionArg (vmls, "action_arg", &objp->action_arg))
		 return FALSE;
	 vml_class_end(vmls,"ActionBilinearArg",name);
	return TRUE;
}
	 bool ApproxDescr::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool ApproxDescr::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool ApproxDescr::Vml(VML *vmls,char *instance){
		 if(!vml_ApproxDescr(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_ApproxDescr (VML *vmls, char *name,ApproxDescr *objp)
{
	 vml_class_begin(vmls,"ApproxDescr",name);
	 if (!vml_RationalApproxType (vmls, "approx_type", &objp->approx_type))
		 return FALSE;
	 if (!vml_RationalBoundsType (vmls, "bounds_type", &objp->bounds_type))
		 return FALSE;
	 if (!vml_Float (vmls, "lambda_low", &objp->lambda_low))
		 return FALSE;
	 if (!vml_Float (vmls, "lambda_high", &objp->lambda_high))
		 return FALSE;
	 if (!vml_array (vmls, "stop_rsd", (char **)&objp->stop_rsd.stop_rsd_val, (u_int *) &objp->stop_rsd.stop_rsd_len, ~0,
		sizeof (Float), (vmlproc_t) vml_Float))
		 return FALSE;
	 vml_class_end(vmls,"ApproxDescr",name);
	return TRUE;
}
	 bool RationalDescr::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool RationalDescr::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool RationalDescr::Vml(VML *vmls,char *instance){
		 if(!vml_RationalDescr(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_RationalDescr (VML *vmls, char *name,RationalDescr *objp)
{
	 vml_class_begin(vmls,"RationalDescr",name);
	 if (!vml_FieldType (vmls, "field_type", &objp->field_type))
		 return FALSE;
	 if (!vml_int (vmls, "power_num", &objp->power_num))
		 return FALSE;
	 if (!vml_int (vmls, "power_den", &objp->power_den))
		 return FALSE;
	 if (!vml_long (vmls, "precision", &objp->precision))
		 return FALSE;
	 if (!vml_Float (vmls, "stop_rsd_fg_mult", &objp->stop_rsd_fg_mult))
		 return FALSE;
	 if (!vml_ApproxDescr (vmls, "md_approx", &objp->md_approx))
		 return FALSE;
	 if (!vml_ApproxDescr (vmls, "mc_approx", &objp->mc_approx))
		 return FALSE;
	 if (!vml_Float (vmls, "stag_bsn_mass", &objp->stag_bsn_mass))
		 return FALSE;
	 vml_class_end(vmls,"RationalDescr",name);
	return TRUE;
}
	 bool EigenDescr::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool EigenDescr::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool EigenDescr::Vml(VML *vmls,char *instance){
		 if(!vml_EigenDescr(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_EigenDescr (VML *vmls, char *name,EigenDescr *objp)
{
	 vml_class_begin(vmls,"EigenDescr",name);
	 if (!vml_EigenMeasure (vmls, "eigen_measure", &objp->eigen_measure))
		 return FALSE;
	 if (!vml_Float (vmls, "stop_rsd", &objp->stop_rsd))
		 return FALSE;
	 if (!vml_int (vmls, "max_num_iter", &objp->max_num_iter))
		 return FALSE;
	 if (!vml_string (vmls, "eig_lo_stem", &objp->eig_lo_stem, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "eig_hi_stem", &objp->eig_hi_stem, ~0))
		 return FALSE;
	 vml_class_end(vmls,"EigenDescr",name);
	return TRUE;
}
	 bool ActionRationalArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool ActionRationalArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool ActionRationalArg::Vml(VML *vmls,char *instance){
		 if(!vml_ActionRationalArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_ActionRationalArg (VML *vmls, char *name,ActionRationalArg *objp)
{
	 vml_class_begin(vmls,"ActionRationalArg",name);
	 if (!vml_ActionBilinearArg (vmls, "bi_arg", &objp->bi_arg))
		 return FALSE;
	 if (!vml_int (vmls, "remez_generate", &objp->remez_generate))
		 return FALSE;
	 if (!vml_string (vmls, "rat_poles_file", &objp->rat_poles_file, ~0))
		 return FALSE;
	 if (!vml_array (vmls, "rationals", (char **)&objp->rationals.rationals_val, (u_int *) &objp->rationals.rationals_len, ~0,
		sizeof (RationalDescr), (vmlproc_t) vml_RationalDescr))
		 return FALSE;
	 if (!vml_EigenDescr (vmls, "eigen", &objp->eigen))
		 return FALSE;
	 vml_class_end(vmls,"ActionRationalArg",name);
	return TRUE;
}
	 bool SplitRange::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool SplitRange::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool SplitRange::Vml(VML *vmls,char *instance){
		 if(!vml_SplitRange(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_SplitRange (VML *vmls, char *name,SplitRange *objp)
{
	 vml_class_begin(vmls,"SplitRange",name);
	 if (!vml_int (vmls, "split_low", &objp->split_low))
		 return FALSE;
	 if (!vml_int (vmls, "split_high", &objp->split_high))
		 return FALSE;
	 vml_class_end(vmls,"SplitRange",name);
	return TRUE;
}
	 bool ActionRationalSplitArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool ActionRationalSplitArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool ActionRationalSplitArg::Vml(VML *vmls,char *instance){
		 if(!vml_ActionRationalSplitArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_ActionRationalSplitArg (VML *vmls, char *name,ActionRationalSplitArg *objp)
{
	 vml_class_begin(vmls,"ActionRationalSplitArg",name);
	 if (!vml_array (vmls, "fractionSplit", (char **)&objp->fractionSplit.fractionSplit_val, (u_int *) &objp->fractionSplit.fractionSplit_len, ~0,
		sizeof (SplitRange), (vmlproc_t) vml_SplitRange))
		 return FALSE;
	 vml_class_end(vmls,"ActionRationalSplitArg",name);
	return TRUE;
}
	 bool BosonDescr::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool BosonDescr::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool BosonDescr::Vml(VML *vmls,char *instance){
		 if(!vml_BosonDescr(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_BosonDescr (VML *vmls, char *name,BosonDescr *objp)
{
	 vml_class_begin(vmls,"BosonDescr",name);
	 if (!vml_Float (vmls, "epsilon", &objp->epsilon))
		 return FALSE;
	 if (!vml_Float (vmls, "stop_rsd_hb", &objp->stop_rsd_hb))
		 return FALSE;
	 vml_class_end(vmls,"BosonDescr",name);
	return TRUE;
}
	 bool ActionBosonArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool ActionBosonArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool ActionBosonArg::Vml(VML *vmls,char *instance){
		 if(!vml_ActionBosonArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_ActionBosonArg (VML *vmls, char *name,ActionBosonArg *objp)
{
	 vml_class_begin(vmls,"ActionBosonArg",name);
	 if (!vml_ActionBilinearArg (vmls, "bi_arg", &objp->bi_arg))
		 return FALSE;
	 if (!vml_array (vmls, "bosons", (char **)&objp->bosons.bosons_val, (u_int *) &objp->bosons.bosons_len, ~0,
		sizeof (BosonDescr), (vmlproc_t) vml_BosonDescr))
		 return FALSE;
	 vml_class_end(vmls,"ActionBosonArg",name);
	return TRUE;
}
	 bool FermionDescr::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool FermionDescr::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool FermionDescr::Vml(VML *vmls,char *instance){
		 if(!vml_FermionDescr(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_FermionDescr (VML *vmls, char *name,FermionDescr *objp)
{
	 vml_class_begin(vmls,"FermionDescr",name);
	 if (!vml_Float (vmls, "epsilon", &objp->epsilon))
		 return FALSE;
	 if (!vml_int (vmls, "chrono", &objp->chrono))
		 return FALSE;
	 if (!vml_Float (vmls, "stop_rsd_fg_mult", &objp->stop_rsd_fg_mult))
		 return FALSE;
	 if (!vml_Float (vmls, "stop_rsd_md", &objp->stop_rsd_md))
		 return FALSE;
	 if (!vml_Float (vmls, "stop_rsd_mc", &objp->stop_rsd_mc))
		 return FALSE;
	 vml_class_end(vmls,"FermionDescr",name);
	return TRUE;
}
	 bool ActionFermionArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool ActionFermionArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool ActionFermionArg::Vml(VML *vmls,char *instance){
		 if(!vml_ActionFermionArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_ActionFermionArg (VML *vmls, char *name,ActionFermionArg *objp)
{
	 vml_class_begin(vmls,"ActionFermionArg",name);
	 if (!vml_ActionBilinearArg (vmls, "bi_arg", &objp->bi_arg))
		 return FALSE;
	 if (!vml_array (vmls, "fermions", (char **)&objp->fermions.fermions_val, (u_int *) &objp->fermions.fermions_len, ~0,
		sizeof (FermionDescr), (vmlproc_t) vml_FermionDescr))
		 return FALSE;
	 vml_class_end(vmls,"ActionFermionArg",name);
	return TRUE;
}
	 bool QuotientDescr::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QuotientDescr::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QuotientDescr::Vml(VML *vmls,char *instance){
		 if(!vml_QuotientDescr(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QuotientDescr (VML *vmls, char *name,QuotientDescr *objp)
{
	 vml_class_begin(vmls,"QuotientDescr",name);
	 if (!vml_Float (vmls, "bsn_mass", &objp->bsn_mass))
		 return FALSE;
	 if (!vml_Float (vmls, "bsn_mass_epsilon", &objp->bsn_mass_epsilon))
		 return FALSE;
	 if (!vml_Float (vmls, "frm_mass", &objp->frm_mass))
		 return FALSE;
	 if (!vml_Float (vmls, "frm_mass_epsilon", &objp->frm_mass_epsilon))
		 return FALSE;
	 if (!vml_int (vmls, "chrono", &objp->chrono))
		 return FALSE;
	 if (!vml_Float (vmls, "stop_rsd_hb", &objp->stop_rsd_hb))
		 return FALSE;
	 if (!vml_Float (vmls, "stop_rsd_fg_mult", &objp->stop_rsd_fg_mult))
		 return FALSE;
	 if (!vml_Float (vmls, "stop_rsd_md", &objp->stop_rsd_md))
		 return FALSE;
	 if (!vml_Float (vmls, "stop_rsd_mc", &objp->stop_rsd_mc))
		 return FALSE;
	 vml_class_end(vmls,"QuotientDescr",name);
	return TRUE;
}
	 bool ActionQuotientArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool ActionQuotientArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool ActionQuotientArg::Vml(VML *vmls,char *instance){
		 if(!vml_ActionQuotientArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_ActionQuotientArg (VML *vmls, char *name,ActionQuotientArg *objp)
{
	 vml_class_begin(vmls,"ActionQuotientArg",name);
	 if (!vml_ActionBilinearArg (vmls, "bi_arg", &objp->bi_arg))
		 return FALSE;
	 if (!vml_array (vmls, "quotients", (char **)&objp->quotients.quotients_val, (u_int *) &objp->quotients.quotients_len, ~0,
		sizeof (QuotientDescr), (vmlproc_t) vml_QuotientDescr))
		 return FALSE;
	 vml_class_end(vmls,"ActionQuotientArg",name);
	return TRUE;
}
	 bool ActionRationalQuotientArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool ActionRationalQuotientArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool ActionRationalQuotientArg::Vml(VML *vmls,char *instance){
		 if(!vml_ActionRationalQuotientArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_ActionRationalQuotientArg (VML *vmls, char *name,ActionRationalQuotientArg *objp)
{
	 vml_class_begin(vmls,"ActionRationalQuotientArg",name);
	 if (!vml_ActionBilinearArg (vmls, "bi_arg", &objp->bi_arg))
		 return FALSE;
	 if (!vml_Float (vmls, "spread", &objp->spread))
		 return FALSE;
	 if (!vml_int (vmls, "remez_generate", &objp->remez_generate))
		 return FALSE;
	 if (!vml_string (vmls, "rat_poles_file", &objp->rat_poles_file, ~0))
		 return FALSE;
	 if (!vml_array (vmls, "bsn_mass", (char **)&objp->bsn_mass.bsn_mass_val, (u_int *) &objp->bsn_mass.bsn_mass_len, ~0,
		sizeof (Float), (vmlproc_t) vml_Float))
		 return FALSE;
	 if (!vml_array (vmls, "frm_mass", (char **)&objp->frm_mass.frm_mass_val, (u_int *) &objp->frm_mass.frm_mass_len, ~0,
		sizeof (Float), (vmlproc_t) vml_Float))
		 return FALSE;
	 if (!vml_array (vmls, "bosons", (char **)&objp->bosons.bosons_val, (u_int *) &objp->bosons.bosons_len, ~0,
		sizeof (RationalDescr), (vmlproc_t) vml_RationalDescr))
		 return FALSE;
	 if (!vml_array (vmls, "fermions", (char **)&objp->fermions.fermions_val, (u_int *) &objp->fermions.fermions_len, ~0,
		sizeof (RationalDescr), (vmlproc_t) vml_RationalDescr))
		 return FALSE;
	 if (!vml_EigenDescr (vmls, "eigen", &objp->eigen))
		 return FALSE;
	 vml_class_end(vmls,"ActionRationalQuotientArg",name);
	return TRUE;
}
	 bool ActionGaugeArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool ActionGaugeArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool ActionGaugeArg::Vml(VML *vmls,char *instance){
		 if(!vml_ActionGaugeArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_ActionGaugeArg (VML *vmls, char *name,ActionGaugeArg *objp)
{
	 vml_class_begin(vmls,"ActionGaugeArg",name);
	 if (!vml_GclassType (vmls, "gluon", &objp->gluon))
		 return FALSE;
	 if (!vml_ActionArg (vmls, "action_arg", &objp->action_arg))
		 return FALSE;
	 vml_class_end(vmls,"ActionGaugeArg",name);
	return TRUE;
}
CPS_END_NAMESPACE
