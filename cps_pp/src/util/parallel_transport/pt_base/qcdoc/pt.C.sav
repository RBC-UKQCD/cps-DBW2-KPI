/*! \file
  \brief  Definition of parallel transport definitions for QCDOC.
  
  $Id: pt.C.sav,v 1.1 2006-07-05 18:13:49 chulwoo Exp $
*/
//--------------------------------------------------------------------
//  CVS keywords
//
//  $Author: chulwoo $
//  $Date: 2006-07-05 18:13:49 $
//  $Header: /home/chulwoo/CPS/repo/CVS/cps_only/cps_pp/src/util/parallel_transport/pt_base/qcdoc/pt.C.sav,v 1.1 2006-07-05 18:13:49 chulwoo Exp $
//  $Id: pt.C.sav,v 1.1 2006-07-05 18:13:49 chulwoo Exp $
//  $Name: not supported by cvs2svn $
//  $Locker:  $
//  $RCSfile: pt.C.sav,v $
//  $Revision: 1.1 $
//  $Source: /home/chulwoo/CPS/repo/CVS/cps_only/cps_pp/src/util/parallel_transport/pt_base/qcdoc/pt.C.sav,v $
//  $State: Exp $
//
//--------------------------------------------------------------------
#include "asq_data_types.h"
#include "pt_int.h"

static unsigned long PEC = 0xb0000000;
static unsigned long PLB = 0xb0000000;

#define TESTING
#undef TESTING
#undef CPP
//CPS_START_NAMESPACE
//void dirac_cmv_jcw_agg_cpp( int sites, long chi, long u,long in, long out);

//External function definitions
extern "C"{

  //matrix multiply for checkerboarded fields
  void pt_cmm_cpp(int sites, long u, long in, long out, long gauge_field);
  void pt_cmm_dag_cpp(int sites, long u, long in, long out, long gauge_field);

  //------------------------------------------------------------------------
  //C++ routines
#ifdef CPP
  //Matrix multiplication for full matrix fields
  void cmm_agg_cpp(gauge_agg *chi, matrix *phi, matrix *result, int counter);
  void cmv_agg_cpp( int sites, long u,long in, long out);
  #define partrans_cmm_agg(A,B,C,D) cmm_agg_cpp(A,B,C,D)
  #define partrans_cmv_agg(A,B,C,D) cmv_agg_cpp(A,B,C,D)

  //matrix vector multiply for checkerboarded fields
  void pt_cmv_cpp(int sites, ind_agg *agg, double *gauge_field, double *src, double *dest);
  void pt_cmv_dag_cpp(int sites, ind_agg *agg, double *gauge_field, double *src, double *dest);
  void pt_cmv_pad_cpp(int sites, ind_agg *agg, double *gauge_field, double *src, double *dest);
  void pt_cmv_dag_pad_cpp(int sites, ind_agg *agg, double *gauge_field, double *src, double *dest);
  #define partrans_cmv(A,B,C,D,E) pt_cmv_cpp(A,B,C,D,E)
  #define partrans_cmv_dag(A,B,C,D,E) pt_cmv_dag_cpp(A,B,C,D,E)
  #define partrans_cmv_pad(A,B,C,D,E) pt_cmv_pad_cpp(A,B,C,D,E)
  #define partrans_cmv_dag_pad(A,B,C,D,E) pt_cmv_dag_pad_cpp(A,B,C,D,E)
  //--------------------------------------------------------------------------
  //Assembly Routines
#else
  //Matrix multiplication for full matrix fields
  void pt_cmm_agg(gauge_agg *chi, matrix *phi,matrix *result, int counter);
  //void cmm_agg(gauge_agg *chi, matrix *phi,matrix *result, int counter);
  void pt_asqtad_agg( int sites, long chi, long u,long in, long out);
  void pt_asqtad_agg_s( int sites, long chi, long u,long in, long out);
  #define partrans_cmm_agg(A,B,C,D) pt_cmm_agg(A,B,C,D)
  #define partrans_cmv_agg(A,B,C,D) pt_asqtad_agg(A,0,B,C,D)

  void pt_cmv(int count, ind_agg *ind, double *gauge, double *src, double *dest);
  void pt_cmv_pad(int count, ind_agg *ind, double *gauge, double *src, double *dest);
  void pt_cmv_dag(int count, ind_agg *ind, double *gauge, double *src, double *dest);
  void pt_cmv_dag_pad(int count, ind_agg *ind, double *gauge, double *src, double *dest);
  void pt_cmv_s(int count, ind_agg *ind, float *gauge, float *src, float *dest);
  void pt_cmv_pad_s(int count, ind_agg *ind, float *gauge, float *src, float *dest);
  void pt_cmv_dag_s(int count, ind_agg *ind, float *gauge, float *src, float *dest);
  void pt_cmv_dag_pad_s(int count, ind_agg *ind, float *gauge, float *src, float *dest);
  #define partrans_cmv(A,B,C,D,E) pt_cmv(A,B,C,D,E)
  #define partrans_cmv_dag(A,B,C,D,E) pt_cmv_dag(A,B,C,D,E)
  #define partrans_cmv_pad(A,B,C,D,E) pt_cmv_pad(A,B,C,D,E)
  #define partrans_cmv_dag_pad(A,B,C,D,E) pt_cmv_dag_pad(A,B,C,D,E)
#endif
  //--------------------------------------------------------------------------

  void pt_copy(int count, ind_agg *ind, double *src, double *dest);
  void pt_copy_pad(int count, ind_agg *ind, double *src, double *dest);
  void pt_copy_s(int count, ind_agg *ind, float *src, float *dest);
  void pt_copy_pad_s(int count, ind_agg *ind, float *src, float *dest);

  void pt_copy_buffer(int n, long src, long dest, long ptable);
  // Assembler copying routines
  void copy_matrix(IFloat *res, IFloat *src, int *length, 
		   unsigned long *res_ptr, unsigned long *src_ptr);
  void copy_gauge(IFloat *res, struct gauge_agg *src, int *length,
		  unsigned long *res_ptr);
  // This is perhaps overkill but gives a couple of extra flops
  // cross_look - all input fields are lookup and sum to result
  void cross_look(IFloat *result, Float *fac, const IFloat *chi, const IFloat *phi,  
	     int counter, unsigned long *src, unsigned long *dest);
  // cross_lin - one input field is linear and sum to result
  void cross_lin(IFloat *result, Float *fac, const IFloat *chi, const IFloat *phi,  
	     int counter, unsigned long *dest, unsigned long *dest);
  // cross_over_look - all input fields are lookup and overwrite result
  void cross_over_look(IFloat *result, Float *fac, const IFloat *chi, const IFloat *phi,  
	     int counter, unsigned long *src, unsigned long *dest);
  // cross_over_lin - one input field is linear and overwrite result
  void cross_over_lin(IFloat *result, Float *fac, const IFloat *chi, const IFloat *phi,  
	     int counter, unsigned long *dest, unsigned long *dest);
  //Copies a vectors from v to u
  void copy_vector(IFloat *u, IFloat *v, int *length, unsigned long *dest, unsigned long *src);

  //---------------------------------------------------------------------------
  
  //---------------------------------------------------------------------------

  void m1m2_lookup(matrix *result, matrix *m1, matrix *m2, int length,
		   unsigned long *dest, unsigned long *dest, unsigned long *src);
  void m1m2_lookup_copy(matrix *result2, matrix *result, matrix *m1, matrix *m2, 
			int length, unsigned long *dest2,  
			unsigned long *dest, unsigned long *dest, 
			unsigned long *src);
  void m1m2_lin_copy(matrix *result2, matrix *result, matrix *m1, matrix *m2, 
		     int length, unsigned long *dest2,
		     unsigned long *dest, unsigned long *dest);
  
}
inline  void pt_cmm_agg_print(gauge_agg *chi, matrix *phi,matrix *result, int counter){
   printf("pt_cmm_agg(%p %p %p %d)\n",chi,phi,result,counter);
//    for(int i =0;i<2*counter;i++){
//      printf("%d: %d %d\n",i,chi[i].src,chi[i].dest);
//    }
   printf("pt_cmm_agg(%p %p %p %d) done \n",chi,phi,result,counter);
}

inline  void cross_over_lin_cpp(IFloat *result, Float *fac, const IFloat *chi,
 const IFloat *phi,  int counter, unsigned long *src, unsigned long *dest){
    printf("cross_over_lin(%p %0.4f %p %p %d %p %p)\n",
    result,*fac,chi,phi,counter,src,dest);
    for(int i =0;i<counter;i++){
      printf("%d: %d %d\n",i,src[i],dest[i]);
    }
    cross_over_lin(result,fac,chi,phi,counter,src,dest);
    printf("cross_over_lin(%p %0.4f %p %p %d %p %p) done\n");
}

inline  void cross_over_look_cpp(IFloat *result, Float *fac, const IFloat *chi,
 const IFloat *phi,  int counter, unsigned long *src, unsigned long *dest){
    printf("cross_over_look(%p %0.4f %p %p %d %p %p)\n",
    result,*fac,chi,phi,counter,src,dest);
    for(int i =0;i<counter;i++){
      printf("%d: %d %d\n",i,src[i],dest[i]);
    }
    cross_over_look(result,fac,chi,phi,counter,src,dest);
    printf("cross_over_look(%p %0.4f %p %p %d %p %p) done\n");
}

#ifdef ASQD_SINGLE
#define pt_asqtad_agg(A,B,C,D,E) pt_asqtad_agg_s(A,B,C,D,E)
#define pt_cmv(A,B,C,D,E) pt_cmv_s(A,B,C,D,E)
#define pt_cmv_dag(A,B,C,D,E) pt_cmv_dag_s(A,B,C,D,E)
#define pt_cmv_pad(A,B,C,D,E) pt_cmv_pad_s(A,B,C,D,E)
#define pt_cmv_dag_pad(A,B,C,D,E) pt_cmv_dag_pad_s(A,B,C,D,E)
#define pt_copy_pad(A,B,C,D) pt_copy_pad_s(A,B,C,D)
#define pt_copy(A,B,C,D) pt_copy_s(A,B,C,D)
#endif


int PT::size[NDIM];
int PT::vol;
int PT::evenodd;
//dest=src
void PT::cpy (IFloat *dest, IFloat *src){
  for(int i=0;i<18;i++)
    dest[i]=src[i];
}

//dest=src.Dagger()
void PT::dag_cpy (IFloat *dest, IFloat *src){
  for(int i=0;i<3;i++)
    for(int j=0;j<3;j++){
      dest[2*(3*i+j)]=src[2*(3*j+i)];
      dest[2*(3*i+j)+1]=-src[2*(3*j+i)+1];
    }
}

//Returns lexical index associated with coordinate x[4]
//where the 0th coordinate runs fastest, 3rd coordinate runs slowest
int PT::lex_xyzt(int *x){
//  printf("lex_xyzt(%d %d %d %d)\n",x[0],x[1],x[2],x[3]);
  int result = x[0] + size[0]*(x[1]+size[1]*(x[2]+size[2]*x[3]));
  return result;
}

//Returns checkerboard index associated with coordinate x[4]
int PT::lex_xyzt_cb_o(int *x){
//  printf("lex_xyzt_cb_o(%d %d %d %d)\n",x[0],x[1],x[2],x[3]);
  int result = x[0] + size[0]*(x[1]+size[1]*(x[2]+size[2]*x[3]));
  if ( (x[0]+x[1]+x[2]+x[3]+evenodd)%2 == 0) result = result/2+vol/2;
  else result = result/2;
  return result;
}

//Returns checkerboard index associated with coordinate x[4]
int PT::lex_xyzt_cb_e(int *x){
//  printf("lex_xyzt_cb_o(%d %d %d %d)\n",x[0],x[1],x[2],x[3]);
  int result = x[0] + size[0]*(x[1]+size[1]*(x[2]+size[2]*x[3]));
  if ( (x[0]+x[1]+x[2]+x[3]+evenodd)%2 == 1) result = result/2+vol/2;
  else result = result/2;
  return result;
}


//---------------------------------------------------------------------------
//Returns index for fields in the STAG storage order on lattice
//sites of a given parity
int PT:: lex_txyz_cb(int *x)
{
//  printf("lex_txyz_cb(%d %d %d %d)\n",x[0],x[1],x[2],x[3]);
  int result = x[3]+size[3]*(x[0]+size[0]*(x[1]+size[1]*x[2]));
  return result/2;
}
//---------------------------------------------------------------------------

//Returns index associated with x[4] for txyz ordering
int PT:: lex_txyz(int *x){
  return  (x[3] + size[3]*(x[0]+size[0]*(x[1]+size[1]*x[2])))/2 ;
}

//Returns first index associated with the surface x[3] = 0, on
//a checkerboarded lattice
int PT:: LexSurface(int *x){
  return  (x[0]+size[0]*(x[1]+size[1]*x[2]))/2 ;
}

//Returns index associated with gauge link in the mu direction 
//and coordinate x
int PT::lex_g_xyzt(int *x, int mu){
  int temp =  lex_xyzt(x);
  return (temp*NDIM + mu);
}

//---------------------------------------------------------------------------
//Returns block ordering for the gauge fields, where all directions
//are stored in one block and sites ordered txyz
int PT::lex_g_txyz(int *x, int mu){
  int temp = mu*vol+x[3] + size[3]*(x[0]+size[0]*(x[1]+size[1]*x[2]));
  return temp;
}

//Returns block ordering for the gauge fields, where all directions
//are stored in one block with sites checkerboarded txyz
int PT::lex_g_txyz_cb(int *x, int mu){
  int result = (x[3]+size[3]*(x[0]+size[0]*(x[1]+size[1]*x[2])))/2;
  return mu*vol + result + ((x[0]+x[1]+x[2]+x[3])%2)*vol/2;
}
//---------------------------------------------------------------------------

//Returns index associated with gauge link in the mu direction and 
//coordinate x for checkerboarded storage
int PT:: lex_g_xyzt_cb_o(int *x, int mu){
  int temp =  lex_xyzt_cb_o(x);
  return (mu*vol+temp);
}
int PT:: lex_g_xyzt_cb_e(int *x, int mu){
  int temp =  lex_xyzt_cb_e(x);
  return (mu*vol+temp);
}

// Calculate the required offset given the direction and hop
int PT::set_offset(int dir, int hop) {

  // if positive direction then start at 0
  if (dir%2 == 0) return 0;

  int temp=1;
  int offset=0;
  for(int i=0;i<dir/2+1;i++){
    offset = temp*(size[i]-hop);
    temp *= size[i];
  }
  return offset;

}

void PT::set_hop_pointer() {

  char *fname = "set_hop_pointer()";

//  VRB.Func("PT",fname);
  //Actual memory usage of vectors
  int vlen = VECT_LEN*sizeof(IFloat);
  int vlen2 =VECT_LEN2*sizeof(IFloat);

  int x[NDIM], nei[NDIM];
  
  //Counts how many parallel transports of given length and direction are local
  //and non-local, respectively
  int hp_local_count[MAX_HOP][2*NDIM];
  int hp_non_local_count[MAX_HOP][2*NDIM];
  int hop, i;


  //Initialize local and non-local hop counters.
  for (hop=0; hop<MAX_HOP; hop++) {
    for (i=0; i<2*NDIM; i++) {
      hp_non_local_count[hop][i] = 0;
      hp_local_count[hop][i] = 0;
    }
  }
  
  //For a given length of the parallel transport
  for (hop = 1; hop <= MAX_HOP; hop++) {
    hop_pointer **h_l = hp_l[hop-1];
    hop_pointer **h_nl = hp_nl[hop-1];

    //Local and non-local counts for given length of the hop
    int *local_count = hp_local_count[hop-1];
    int *non_local_count = hp_non_local_count[hop-1];

    //Loop over all directions
    for (i=0; i<NDIM; i++) {

      //Total number of sites that require non-local communication
      int non_local_check = hop*non_local_chi[i*2];
      //Total number of sites where parallel transport can be done locally
      int local_check = vol - non_local_check;

      //Loop through all the sites on the lattice
      //nei represents the coordinates of the neighboring site.
      for(x[3]=0,nei[3]=0;x[3]<size[3];x[3]++,nei[3]++)
	for(x[2]=0,nei[2]=0;x[2]<size[2];x[2]++,nei[2]++)
	  for(x[1]=0,nei[1]=0;x[1]<size[1];x[1]++,nei[1]++)
	    for(x[0]=0,nei[0]=0;x[0]<size[0];x[0]++,nei[0]++){

	      //This is the parallel transport of the field in the 
	      //negative direction to another node
	      //"Positive hop" because the link variable points in the 
	      //positive direction, even though the resulting field is 
	      //"transported" in the negative direction
	      // positive direction

	      if((x[i] < hop) && (!local[i])){
		//This calculates the neighbor coordinate
		nei[i] = size[i]-hop+x[i];  

		//Sets the index for source and destination
		(h_nl[2*i]+non_local_count[2*i])->src = non_local_count[2*i]*vlen;
		(h_nl[2*i]+non_local_count[2*i])->dest = LexVector(nei)*vlen2;

		//Increments the non-local count
		non_local_count[i*2]++;

		//Make sure we haven't gone over the non non-local check
		if (non_local_count[i*2]>non_local_check)
		  fprintf(stderr,
			"%s:non_local_count[%d](%d)>non_local_check[%d](%d)\n",
			 fname,2*i,non_local_count[2*i],2*i,non_local_check);
		//The rest of the parallel transports in the local volume can 
		//be handled locally
	      } else {
		//Calculate the new coordinate
		nei[i] = (size[i]+x[i]-hop)%size[i];

		//if ( size[i] >2){
		//Calculate the index for the source and the destination
		(h_l[2*i]+local_count[2*i])->src = LexVector(x)*vlen;
		(h_l[2*i]+local_count[2*i])->dest = LexVector(nei)*vlen2;
                //}
		
		//Increment the local count
		local_count[i*2]++;
		//Make sure we haven't exceeded the number of local sites
		if (local_count[i*2]>local_check)
		  fprintf(stderr,"%s:local_count[%d](%d)>local_check[%d](%d)\n",
			      fname,2*i,local_count[2*i],2*i,local_check);
	      }
	      
	      //Consider hopping in the negative direction, which is parallel 
	      //transport in the positive direction
	      // negative direction
	      if( (x[i] >= (size[i]-hop)) && (!local[i])){
		//Calculate the non-local coordinate for this hop
		nei[i] = (x[i]+hop)%size[i];
		//Calculate source and destination indices
		(h_nl[2*i+1]+non_local_count[2*i+1])->src = non_local_count[2*i+1]*vlen;
		(h_nl[2*i+1]+non_local_count[2*i+1])->dest = LexVector(nei)*vlen2;

		//Increment the non-local count, check that bounds have not 
		//been exceeded
		non_local_count[i*2+1]++;
		if (non_local_count[i*2]>non_local_check)
		  fprintf(stderr,"%s:non_local_count[%d](%d)>non_local_check[%d](%d)\n",
			      fname,2*i,non_local_count[2*i],2*i,non_local_check);
	      } else {
		//Calculate the local coordinate for this hop
		nei[i] = (x[i]+hop)%size[i];
		//Calculate source and destination indices
		//if ( size[i] >2){
		(h_l[2*i+1]+local_count[2*i+1])->src = LexVector(x)*vlen;
		(h_l[2*i+1]+local_count[2*i+1])->dest = LexVector(nei)*vlen2;
		//}
		//Increment local count, check that bounds not exceeded
		local_count[i*2+1]++;
		if (local_count[i*2]>local_check)
		  fprintf(stderr,"%s:local_count[%d](%d)>local_check[%d](%d)\n",
			      fname,2*i,local_count[2*i],2*i,local_check);
	      }
	      // Need to reset the neighbour pointer
	      nei[i] = x[i];
	    }
    }
  }
//  VRB.Func("PT",fname);
//  exit(44);
}


//Initialization of Parallel Transport class
void PT::init(PTArg *pt_arg)
{
  char *cname = "";
  char *fname = "pt_init()";
//printf("%s\n",fname);
  int i, j, x[NDIM],nei[NDIM];
  int local_count[2*NDIM];
  int non_local_count[2*NDIM];
  int vlen = VECT_LEN*sizeof(IFloat); //size of incoming vector
  int vlen2 =VECT_LEN2*sizeof(IFloat); //size of outgoing vector (maybe different to optimize for QCDOC PEC)

  //---------------------------------------------------------------------------
  int local_count_cb[2][2*NDIM];
  int non_local_count_cb[2][2*NDIM];
  //---------------------------------------------------------------------------

  size[0] = pt_arg->size[0];
  size[1] = pt_arg->size[1];
  size[2] = pt_arg->size[2];
  size[3] = pt_arg->size[3];
  local[0] = pt_arg->local[0];
  local[1] = pt_arg->local[1];
  local[2] = pt_arg->local[2];
  local[3] = pt_arg->local[3];
  non_local_dirs = 2*(4-local[0]-local[1]-local[2]-local[3]);
  //printf("Local directions = %d %d %d %d\n", local[0],local[1],local[2],local[3]);

  gauge_field_addr = pt_arg->gauge_field_addr;
  g_str_ord = pt_arg->g_str_ord;
  g_conj = pt_arg->g_conj;
  v_str_ord = pt_arg->v_str_ord;
  v_str_ord_cb = pt_arg->v_str_ord_cb;
  evenodd = pt_arg->evenodd;
  prec = pt_arg->prec;

  switch(g_str_ord){
    case PT_XYZT:
      LexGauge = lex_g_xyzt;
      LexGauge2 = lex_g_txyz_cb;
      break;
    case PT_XYZT_CB_O:
      LexGauge = lex_g_xyzt_cb_o;
      LexGauge2 = lex_g_txyz_cb;
      break;
    case PT_XYZT_CB_E:
      LexGauge = lex_g_xyzt_cb_e;
      LexGauge2 = lex_g_txyz_cb;
      break;
    default:
      fprintf(stderr,"PT::init got invalid g_str_ord\n");
      break;
  }

  switch(v_str_ord){
    case PT_XYZT:
      LexVector = lex_xyzt;
      break;
    case PT_XYZT_CB_O:
      LexVector = lex_xyzt_cb_o;
      break;
    default:
      fprintf(stderr,"PT::init got invalid v_str_ord\n");
      break;
  }

  switch(v_str_ord_cb){
    case PT_TXYZ:
      LexVector_cb = lex_txyz_cb;
      break;
    default:
      fprintf(stderr,"PT::init got invalid v_str_ord_cb\n");
      break;
  }
  
  if (g_conj) { Copy = &dag_cpy; DagCopy = &cpy; conjugated = PT_DAG_YES;}
  else        { Copy = &cpy; DagCopy = &dag_cpy; conjugated = PT_DAG_NO;}


  //For the fastest changing index, data must be sent in many short messages
  //For the slowest changing index, the boundaries of the hypersurface are 
  //stored together in large blocks, so a few long messages can be sent.

  blklen[0] = blklen[1]= vlen;
  for(i=1;i<NDIM;i++) {blklen[2*i+1] = blklen[2*i] = blklen[2*i-1]*size[i-1]; }

  numblk[2*NDIM-1]=numblk[2*NDIM-2]=1;
  for(i=NDIM-2;i>=0;i--) {numblk[i*2+1] = numblk[2*i] = numblk[2*i+2]*size[i+1]; }

  //The stride length is longer when the blocks are large
  for(i=0;i<NDIM*2;i++)  stride[i] = blklen[i]* (size[i/2]-1);

  //Calculate the local volume
  vol = 1;
  for(i=0; i<NDIM;i++) vol *= size[i];

  //Calculate the number of local and non-local parallel transports
  //are needed in each direction
  for(i=0; i<NDIM;i++) {
    if (local[i])
      non_local_chi[2*i+1] = non_local_chi[2*i] = 0;
    else 
      non_local_chi[2*i+1] = non_local_chi[2*i] = vol/size[i];
    local_chi[2*i+1] = local_chi[2*i] = vol - non_local_chi[2*i];
//printf("local_chi[%d]=%d non_local_chi[%d]=%d\n", i*2,local_chi[i*2],i*2,non_local_chi[i*2]);
//printf("local_chi[%d]=%d non_local_chi[%d]=%d\n", i*2+1,local_chi[i*2+1],i*2+1,non_local_chi[i*2+1]);
  }

  //---------------------------------------------------------------------------
  //Calculation of block length, number of blocks, and stride for 
  //checkerboarded storage

  //Block length for checkerboarded scheme is similar to canonical scheme
  //However, there must be a few modifications.
  //
  //For the T (3rd) direction, a block strided communciation will not work
  //As a result, pointers to the appropriate fields will be aggregated
  //into a send buffer before being sent as a single block.
  //
  //For transfers in all other directions, a block-strided move is allowed.
  //In these cases, the fastest changing index (X) requires many short messages
  //while the slowest changing index (Z) can be transfered in one block
  
  blklen_cb[6] = blklen_cb[7] = vol*vlen/(2*size[3]);
  numblk_cb[6] = numblk_cb[7] = 1;

  blklen_cb[4] = blklen_cb[5] = vol*vlen/(2*size[2]);
  numblk_cb[4] = numblk_cb[5] = 1;

  blklen_cb[2] = blklen_cb[3] = vol*vlen/(2*size[1]*size[2]);
  numblk_cb[2] = blklen_cb[3] = size[2];

  blklen_cb[0] = blklen_cb[1] = vol*vlen/(2*size[0]*size[1]*size[2]);
  numblk_cb[0] = numblk_cb[1] = size[1]*size[2];

  //The stride is also similar
  stride_cb[0] = stride_cb[1] = 0;
  for(i = 0; i < NDIM*2; i++)
      stride_cb[i] = blklen_cb[i] * (size[i/2]-1);
  stride_cb[6] = stride_cb[7] = 0;

  //Calculate the number of local and non-local parallel transports
  for(i = 0; i < NDIM; i++)
    {
      if(!local[i])
	non_local_chi_cb[2*i+1] = non_local_chi_cb[2*i] = vol/(2*size[i]);
      else
	non_local_chi_cb[2*i+1] = non_local_chi_cb[2*i] = 0;
      local_chi_cb[2*i+1] = local_chi_cb[2*i] = vol/2 - non_local_chi_cb[2*i];
  //    printf("non_local_chi_cb[2*%d] = %d; local_chi_cb[2*%d] = %d\n",i,non_local_chi_cb[2*i],i,local_chi_cb[2*i]);
    }

  //---------------------------------------------------------------------------

  for(i=0; i<2*NDIM;i++){
    local_count[i]=non_local_count[i]=0;
    //-------------------------------------------------------------------------
    for(int parity = 0; parity < 2; parity++)
      local_count_cb[parity][i] = non_local_count_cb[parity][i] = 0;
    //------------------------------------------------------------------------


      uc_l[i] = (gauge_agg *)Alloc(cname,fname,"uc_l[i]",
				     sizeof(gauge_agg)*(1+local_chi[i]));
      uc_nl[i] = (gauge_agg *)Alloc(cname,fname,"uc_nl[i]",
				      sizeof(gauge_agg)*(1+non_local_chi[i]));

    //-------------------------------------------------------------------------
    //Allocate memory for gauge_agg_cb
    for(int parity = 0; parity < 2; parity++)
    {
      uc_l_cb[parity][i] = (gauge_agg_cb *)FastAlloc(cname,fname,"uc_l_cb",sizeof(gauge_agg_cb)*(1+local_chi_cb[i]));
      uc_nl_cb[parity][i] = (gauge_agg_cb *)FastAlloc(cname,fname,"uc_nl_cb",sizeof(gauge_agg_cb)*(1+non_local_chi_cb[i]));

      uc_l_pad_cb[parity][i] = (gauge_agg_cb *)(unsigned long)FastAlloc(cname,fname,"uc_l_pad_cb",sizeof(gauge_agg_cb)*(1+local_chi_cb[i]));
      uc_nl_pad_cb[parity][i] = (gauge_agg_cb *)(unsigned long)FastAlloc(cname,fname,"uc_nl_pad_cb",sizeof(gauge_agg_cb)*(1+non_local_chi_cb[i]));
//      printf("uc_pad_cb = %p %p\n",uc_l_pad_cb[parity][i],uc_nl_pad_cb[parity][i]);
    }

    //-------------------------------------------------------------------------

    // This buffer is actually overkill, but ensures will work if
    // shift_field is called with hop>1
    if(non_local_chi[i]>0){
      rcv_buf[i] = (IFloat *)FastAlloc(3*MAX_HOP*non_local_chi[i]*vlen);
    if(!rcv_buf[i])PointerErr("",fname,"rcv_buf[i]");

    //Used buffer used in vvpd
      rcv_buf2[i] = (IFloat *)FastAlloc(MAX_HOP*non_local_chi[i]*vlen);
      if(!rcv_buf2[i])PointerErr("",fname,"rcv_buf2[i]");
    } else{
      rcv_buf[i] = rcv_buf2[i] = NULL;
    }
  }

  //---------------------------------------------------------------------------
  //Allocate memory for send buffer

  for(i=0; i<NDIM;i++)
    if(non_local_chi_cb[2*i+1])
    {
      snd_buf_cb[i] = (IFloat *)FastAlloc(cname,fname,"snd_buf_cb[i]",3*non_local_chi_cb[2*i+1]*vlen);
    } else
      snd_buf_cb[i] = NULL;
  if(non_local_chi_cb[6]){
    snd_buf_t_cb = (IFloat *)FastAlloc("",fname,"snd_buf_t_cb",3*non_local_chi_cb[6]*vlen);
  } else
    snd_buf_t_cb = NULL;

  for(i = 0; i < 2;i++)
    if(non_local_chi_cb[6])
    Toffset[i] = (int *)FastAlloc(cname,fname,"Toffset[parity]",non_local_chi_cb[6]*sizeof(int));
    else Toffset[i]=NULL;

  //Allocate memory for the gauge_agg_cb used for matrix pre-multiplication

  for(i = 0; i< NDIM;i++)
    for(int parity = 0; parity<2;parity++)
      uc_nl_cb_pre[parity][i] = (gauge_agg_cb *)FastAlloc(cname,fname,"uc_nl_cb_pre[parity][i]",sizeof(gauge_agg_cb)*(1+non_local_chi_cb[2*i+1]));

  int parity = 0;
  //---------------------------------------------------------------------------
 
  //Calculate source and destination indices for gauge aggregates (see set_hop_pointer())
  //Only for one hop
   for(x[3]=0,nei[3]=0;x[3]<size[3];x[3]++,nei[3]++)
    for(x[2]=0,nei[2]=0;x[2]<size[2];x[2]++,nei[2]++)
      for(x[1]=0,nei[1]=0;x[1]<size[1];x[1]++,nei[1]++)
	for(x[0]=0,nei[0]=0;x[0]<size[0];x[0]++,nei[0]++){
	  for(i=0;i<NDIM;i++){
	    
//	    printf("%d %d %d %d %d\n",x[0],x[1],x[2],x[3],i);
	    // positive direction
	    //This is for transport of a vector in the negative direction
	    //An even index for uc_nl, uc_l, uc_nl_cb, uc_l_cb corresponds
	    //to parallel transport in the negative direction
	    
	    if( (x[i] == 0) && (!local[i])){
	      nei[i] = size[i]-1;
	      (uc_nl[2*i]+non_local_count[2*i])->src = non_local_count[2*i]*vlen;
	      (uc_nl[2*i]+non_local_count[2*i])->dest = LexVector(nei)*vlen2;
	      non_local_count[i*2]++;
	      if (non_local_count[i*2]>non_local_chi[i*2])
		fprintf(stderr,"%s:non_local_count[%d](%d)>non_local_chi[%d](%d)\n",
			fname,2*i,non_local_count[2*i],2*i,non_local_chi[2*i]);
	    } 
	    else {
	      nei[i] = (x[i]-1+size[i])%size[i];
	      if(local_count[2*i]<0) fprintf(stderr,"%s:local_count[%d]=%d]n",
			fname,2*i,local_count[2*i]);
	      (uc_l[2*i]+local_count[2*i])->src = LexVector(x)*vlen;
	      (uc_l[2*i]+local_count[2*i])->dest = LexVector(nei)*vlen2;
	      local_count[i*2]++;
	      if (local_count[i*2]>local_chi[i*2])
		fprintf(stderr,"%s:local_count[%d](%d)>local_chi[%d](%d)\n",
			fname,2*i,local_count[2*i],2*i,local_chi[2*i]);
	    }
	    // negative direction
	    //This is parallel transport in the positive direction
	    //An odd index for uc_l, uc_nl, uc_l_cb,uc_nl_cb corresponds to
	    //transport in the positive direction
	    if((x[i] == (size[i] -1))  && (!local[i])){
	      nei[i] = 0;
	      (uc_nl[2*i+1]+non_local_count[2*i+1])->src = non_local_count[2*i+1]*vlen;
	      (uc_nl[2*i+1]+non_local_count[2*i+1])->dest = LexVector(nei)*vlen2;
	      non_local_count[i*2+1]++;
	      if (non_local_count[i*2+1]>non_local_chi[i*2+1])
		fprintf(stderr,"%s:non_local_count[%d](%d)>non_local_chi[%d](%d)\n",
			fname,2*i+1,non_local_count[2*i+1],2*i+1,non_local_chi[2*i+1]);
	    } else {
	      nei[i] = (x[i]+1)%size[i];
	      if(local_count[2*i+1]<0) fprintf(stderr,"%s:local_count[%d]=%d]n",
					       fname,2*i+local_count[2*i+1]);
	      (uc_l[2*i+1]+local_count[2*i+1])->src = LexVector(x)*vlen;
	      (uc_l[2*i+1]+local_count[2*i+1])->dest = LexVector(nei)*vlen2;
	      local_count[i*2+1]++;
	      if (local_count[i*2+1]>local_chi[i*2+1])
		fprintf(stderr,"%s:local_count[%d](%d)>local_chi[%d](%d)\n",
			fname,2*i+1,local_count[2*i+1],2*i+1,local_chi[2*i+1]);
	    }
	    nei[i] = x[i];
	  }
	}

   //--------------------------------------------------------------------------
  //Calculate source and destination indices for gauge aggregates
  //Only for one hop
   for(x[2]=0,nei[2]=0;x[2]<size[2];x[2]++,nei[2]++)
     for(x[1]=0,nei[1]=0;x[1]<size[1];x[1]++,nei[1]++)
       for(x[0]=0,nei[0]=0;x[0]<size[0];x[0]++,nei[0]++)
	 for(x[3]=0,nei[3]=0;x[3]<size[3];x[3]++,nei[3]++)
	   {

	    parity = (x[0]+x[1]+x[2]+x[3])%2;
	    //Calculate offsets for transfers in the negative T direction
	    if((x[3] == 0) && !local[3])
	      *(Toffset[parity] +non_local_count_cb[parity][6]) = LexVector_cb(x)*VECT_LEN;

	    for(i=0;i<NDIM;i++){

	    // positive direction
	    //This is for transport of a vector in the negative direction
	    //An even index for uc_nl, uc_l, uc_nl_cb, uc_l_cb corresponds
	    //to parallel transport in the negative direction

	      if((x[i] == 0) && !local[i])
	      {
	      nei[i] = size[i]-1;

	      //The src and dest indexes index the Vector, and do not include 
	      //information for the size of the vector, nor
	      //the size of the IFloat object.  This is to allow runt-time 
	      //adjustment of these parameters
	      //
	      //src - Source index in the receive buffer coming from a 
	      //      positive adjacent node
	      //dest - Destination index for the transported vector field
	      //dest2 - Destination index for the padded vector field
	      //gauge_index - Index of the SU(3) gauge link needed to 
	      //              transport the field
	      //dagger - determines if the gauge link needs to be conjugated

	      (uc_nl_cb[parity][2*i]+non_local_count_cb[parity][2*i])->src = non_local_count_cb[parity][2*i]*6*sizeof(IFloat);
	      (uc_nl_cb[parity][2*i]+non_local_count_cb[parity][2*i])->dest = LexVector_cb(nei)*6*sizeof(IFloat);
	      (uc_nl_cb[parity][2*i]+non_local_count_cb[parity][2*i])->gauge = LexGauge2(nei,i)*GAUGE_LEN*sizeof(IFloat);

	      (uc_nl_pad_cb[parity][2*i]+non_local_count_cb[parity][2*i])->src = non_local_count_cb[parity][2*i]*6*sizeof(IFloat);
	      (uc_nl_pad_cb[parity][2*i]+non_local_count_cb[parity][2*i])->dest = (LexVector_cb(nei)*8+2*i)*8*sizeof(IFloat);
	      (uc_nl_pad_cb[parity][2*i]+non_local_count_cb[parity][2*i])->gauge = LexGauge2(nei,i)*GAUGE_LEN*sizeof(IFloat);


	      non_local_count_cb[parity][i*2]++;
	      if(non_local_count_cb[parity][i*2]>non_local_chi_cb[i*2])
		fprintf(stderr,
			"%s:non_local_count_cb[%d][%d](%d)>non_local_chi_cb[%d](%d)\n",
			fname,parity,2*i,non_local_count_cb[parity][2*i],2*i,non_local_chi[2*i]);
	    } 
	    else 
	      {
	      nei[i] = (x[i]+size[i]-1)%size[i];

	      (uc_l_cb[parity][2*i]+local_count_cb[parity][2*i])->src = LexVector_cb(x)*6*sizeof(IFloat);
	      (uc_l_cb[parity][2*i]+local_count_cb[parity][2*i])->dest = LexVector_cb(nei)*6*sizeof(IFloat);
	      (uc_l_cb[parity][2*i]+local_count_cb[parity][2*i])->gauge = LexGauge2(nei,i)*GAUGE_LEN*sizeof(IFloat);

	      (uc_l_pad_cb[parity][2*i]+local_count_cb[parity][2*i])->src = LexVector_cb(x)*6*sizeof(IFloat);
	      (uc_l_pad_cb[parity][2*i]+local_count_cb[parity][2*i])->dest = (LexVector_cb(nei)*8+2*i)*8*sizeof(IFloat);
	      (uc_l_pad_cb[parity][2*i]+local_count_cb[parity][2*i])->gauge = LexGauge2(nei,i)*GAUGE_LEN*sizeof(IFloat);

	      local_count_cb[parity][i*2]++;
	      if(local_count_cb[parity][i*2]>local_chi_cb[i*2])
		fprintf(stderr,"%s:local_count_cb[%d][%d](%d)>local_chi_cb[%d](%d)\n",fname,parity,2*i,local_count_cb[parity][2*i],2*i,local_chi[2*i]);
	      }

	    // negative direction
	    //This is parallel transport in the positive direction
	    //An odd index for uc_l, uc_nl, uc_l_cb,uc_nl_cb corresponds to
	    //transport in the positive direction

	      if((x[i] == (size[i] -1)) && !local[i])
	      {
	      nei[i] = 0;

	      //src - Source index in the receive buffer
	      //dest - Destination index for the transported vector field
	      //In only this case, the field is transported pre-multiplied by
	      //the gauge link.  As a result, gauge_index and dagger are not 
	      //strictly necessary.
	      //
	      //However, we do need to specify another gauge aggregate that 
	      //will contain the information necessary
	      //for the pre-multiplication of the SU(3) link matrix
	      
	      (uc_nl_cb[parity][2*i+1]+non_local_count_cb[parity][2*i+1])->src = non_local_count_cb[parity][2*i+1]*6*sizeof(IFloat);
	      (uc_nl_cb[parity][2*i+1]+non_local_count_cb[parity][2*i+1])->dest = LexVector_cb(nei)*6*sizeof(IFloat);
	      (uc_nl_cb[parity][2*i+1]+non_local_count_cb[parity][2*i+1])->gauge = LexGauge2(x,i)*GAUGE_LEN*sizeof(IFloat);

	      
	      (uc_nl_pad_cb[parity][2*i+1]+non_local_count_cb[parity][2*i+1])->src = non_local_count_cb[parity][2*i+1]*6*sizeof(IFloat);
	      (uc_nl_pad_cb[parity][2*i+1]+non_local_count_cb[parity][2*i+1])->dest = (LexVector_cb(nei)*8+2*i+1)*8*sizeof(IFloat);
	      (uc_nl_pad_cb[parity][2*i+1]+non_local_count_cb[parity][2*i+1])->gauge = LexGauge2(x,i)*GAUGE_LEN*sizeof(IFloat);

	      (uc_nl_cb_pre[parity][i]+non_local_count_cb[parity][2*i+1])->src = LexVector_cb(x)*6*sizeof(IFloat);
	      (uc_nl_cb_pre[parity][i]+non_local_count_cb[parity][2*i+1])->dest = non_local_count_cb[parity][2*i+1]*6*sizeof(IFloat);
	      (uc_nl_cb_pre[parity][i]+non_local_count_cb[parity][2*i+1])->gauge = LexGauge2(x,i)*GAUGE_LEN*sizeof(IFloat);

	      non_local_count_cb[parity][i*2+1]++;
	      if(non_local_count_cb[parity][i*2+1]>non_local_chi_cb[i*2+1])
		fprintf(stderr,"%s:non_local_count_cb[%d][%d](%d)>non_local_chi_cb[%d](%d)\n",fname,parity,2*i+1,non_local_count_cb[parity][2*i+1],2*i+1,non_local_chi[2*i+1]);
	      } 
	    else 
	      {
	      nei[i] = (x[i]+1)%size[i];

	      (uc_l_cb[parity][2*i+1]+local_count_cb[parity][2*i+1])->src = LexVector_cb(x)*6*sizeof(IFloat);
	      (uc_l_cb[parity][2*i+1]+local_count_cb[parity][2*i+1])->dest = LexVector_cb(nei)*6*sizeof(IFloat);
	      (uc_l_cb[parity][2*i+1]+local_count_cb[parity][2*i+1])->gauge = LexGauge2(x,i)*GAUGE_LEN*sizeof(IFloat);
	      (uc_l_pad_cb[parity][2*i+1]+local_count_cb[parity][2*i+1])->src = LexVector_cb(x)*6*sizeof(IFloat);
	      (uc_l_pad_cb[parity][2*i+1]+local_count_cb[parity][2*i+1])->dest = (LexVector_cb(nei)*8+2*i+1)*8*sizeof(IFloat);
	      (uc_l_pad_cb[parity][2*i+1]+local_count_cb[parity][2*i+1])->gauge = LexGauge2(x,i)*GAUGE_LEN*sizeof(IFloat);

	      local_count_cb[parity][i*2+1]++;
	      if(local_count_cb[parity][i*2+1]>local_chi_cb[i*2+1])
		fprintf(stderr,"%s:local_count_cb[%d][%d](%d)>local_chi_cb[%d](%d)\n",fname,parity,2*i+1,local_count_cb[parity][2*i+1],2*i+1,local_chi[2*i+1]);
	    }
	    nei[i] = x[i];
	  }
	}
   //--------------------------------------------------------------------------

  //Sets bits in uc_l and uc_nl to zero
  for(i=0;i<NDIM;i++){
    gauge_agg *tmp = uc_l[2*i]+local_count[2*i];
    memcpy(tmp,tmp-1,sizeof(gauge_agg));
    tmp = uc_l[2*i+1]+local_count[2*i+1];
    memcpy(tmp,tmp-1,sizeof(gauge_agg));
    tmp = uc_nl[2*i]+non_local_count[2*i];
    memcpy(tmp,tmp-1,sizeof(gauge_agg));
    tmp = uc_nl[2*i+1]+non_local_count[2*i+1];
    memcpy(tmp,tmp-1,sizeof(gauge_agg));
  }

  //Calculate offsets?
  //For even array index (transfer in the negative  direction) the
  //offset is 0
  //For odd indexes, the offsets are:
  //offset[1] = size[0]-1
  //offset[3] = size[0]*(size[1]-1)
  //offset[5] = size[0]*size[1]*(size[2]-1)
  //offset[7] = size[0]*size[1]*size[2]*(size[3]-1)
  //These offsets correspond to the starting index for data transfer
  //in the positive direction
  int temp=1;
  for(i=0;i<NDIM;i++){
    offset[2*i]  = 0;
    offset[2*i+1] = temp*(size[i]-1);
    temp *= size[i];
  }

  //-------------------------------------------------------------------
  temp = 1;
  /*
  for(i = 0;i<NDIM;i++)
    {
      offset_cb[2*i] = 0;
      offset_cb[2*i+1] = stride_cb[2*i+1]/sizeof(IFloat);
    }
  */
  //-------------------------------------------------------------------

  // Allocate memory for hop pointers
  for (j=0; j<MAX_HOP; j++) {
  
    for(i=0; i<2*NDIM; i++){
      
      //Calculate the number of local and non-local sites needed 
      //j+1 is the length of the hop
      //i indicates the communication direction
      int nl_size = (j+1)*non_local_chi[i] ;
      int l_size = vol - nl_size ;

      if (l_size>0){
        hp_l[j][i] = (hop_pointer*) FastAlloc(cname,fname,"hp_l[j][i]",(1+l_size)*sizeof(hop_pointer));
        src_l[j][i] = (unsigned long*)FastAlloc(cname,fname,"src_l[j][i]",(1+l_size)*sizeof(unsigned long));
        dest_l[j][i] = (unsigned long*)FastAlloc(cname,fname,"dest_l[j][i]",(1+l_size)*sizeof(unsigned long));
      } else {
        hp_l[j][i] = NULL;
        src_l[j][i] = NULL;
        dest_l[j][i] = NULL;
      }
      if (nl_size>0){
  	hp_nl[j][i] = (hop_pointer*) FastAlloc(cname,fname,"hp_nl[j][i]",(1+nl_size)*sizeof(hop_pointer));
  	src_nl[j][i] = (unsigned long*)FastAlloc(cname,fname,"src_nl[j][i]",(1+nl_size)*sizeof(unsigned long));
  	dest_nl[j][i] = (unsigned long*)FastAlloc(cname,fname,"dest_nl[j][i]",(1+nl_size)*sizeof(unsigned long));
      } else {
        hp_nl[j][i] = NULL;
        src_nl[j][i] = NULL;
        dest_nl[j][i] = NULL;
      }
    }
  }
  
  set_hop_pointer();

  //Calculate the indices for the source and destination
  for (j=0; j<MAX_HOP; j++) {
    for(i=0; i<2*NDIM; i++){
      int nl_size = (j+1)*non_local_chi[i];
      int l_size = vol - nl_size;
      if (l_size>0){
        for (int s=0; s<l_size; s++) {
          src_l[j][i][s] = hp_l[j][i][s].src/(VECT_LEN*sizeof(IFloat));
          dest_l[j][i][s] = hp_l[j][i][s].dest/(VECT_LEN2*sizeof(IFloat));
        }
	src_l[j][i][l_size] = src_l[j][i][l_size-1];
	dest_l[j][i][l_size] = dest_l[j][i][l_size-1] ;
      }
      if (nl_size>0){
        for (int s=0; s<nl_size; s++) {
          src_nl[j][i][s] = hp_nl[j][i][s].src/(VECT_LEN*sizeof(IFloat));
          dest_nl[j][i][s] = hp_nl[j][i][s].dest/(VECT_LEN2*sizeof(IFloat));
        }
	src_nl[j][i][nl_size] = src_nl[j][i][nl_size-1];
	dest_nl[j][i][nl_size] = dest_nl[j][i][nl_size-1] ;
      }
    }
  }
//printf("pt_init() done\n");
	
}

//Free memory associated with the parallel transport of the fermions
void PT::delete_buf(){
  char *fname = "pt_delete()";
	
  for(int i = 0; i < 2*NDIM; i++){
    Free(uc_l[i]);
    Free(uc_nl[i]);
    //--------------------------------------------------------------------

    for(int parity = 0; parity < 2; parity++)
      {
	Free(uc_l_cb[parity][i]);
	Free(uc_nl_cb[parity][i]);
	Free( (void *) ((unsigned long)uc_l_pad_cb[parity][i]-PLB+PEC) );
	Free( (void *) ((unsigned long)uc_nl_pad_cb[parity][i]-PLB+PEC) );
      }

    //-------------------------------------------------------------------
//    sfree(rcv_buf[i],cname,fname,"rcv_buf[i]");
//    sfree(rcv_buf2[i],cname,fname,"rcv_buf2[i]");
    if(non_local_chi[i] > 0)
      {
	Free(rcv_buf[i]);
	Free(rcv_buf2[i]);
      }
  }

  //-----------------------------------------------------------------------

  for(int i = 0; i < NDIM; i++)
    {
//      sfree(snd_buf_cb[i],cname,fname,"snd_buf_cb[i]");
      if(non_local_chi_cb[2*i+1]>0)
	Free(snd_buf_cb[i]);
      for(int parity = 0; parity < 2; parity++)
	Free(uc_nl_cb_pre[parity][i]);
    }
  if(non_local_chi_cb[6] > 0)
    {
      Free(snd_buf_t_cb);
      
      for(int i = 0; i < 2; i++)
	Free(Toffset[i]);    
    }

  //-----------------------------------------------------------------------

  for (int hop=0; hop<MAX_HOP; hop++) {
    for(int i = 0; i < 2*NDIM; i++){
      int nl_size = (hop+1)*non_local_chi[i];
      int l_size = vol - nl_size ;
      if (l_size>0){
        Free(hp_l[hop][i]);
        Free(src_l[hop][i]);
        Free(dest_l[hop][i]);
      }
      if (nl_size>0){
	  Free(hp_nl[hop][i]);
	  Free(src_nl[hop][i]);
	  Free(dest_nl[hop][i]);
      }
    }
  }
}

//Free memory associated with gauge parallel transport
void PT::delete_g_buf(){
  char *fname = "pt_delete_g()";
//  VRB.Func("",fname);
//  printf("gauge_txyz=%p\n",gauge_txyz);
//  Free(gauge_txyz);
  for(int hop = 0; hop < MAX_HOP; hop++)
    for(int i = 0; i < 4*NDIM; i++)
      if(!local[i/4])
      {
	delete SCUarg[hop][i];
	delete SCUarg2[hop][i];
	delete SCUarg_mat[hop][i];
      }

  //----------------------------------------------------------------------
  //Checkerboarding
  for(int i = 0; i < 4*NDIM; i++)
    if(!local[i/4])
    {
      delete SCUarg_cb[i];
      delete SCUarg_mat_cb[i];
      }
  //---------------------------------------------------------------------
}

void PT::init_g(Float * g_addr){
  int x[NDIM], nei[NDIM];
  int local_count[2*NDIM];
  int non_local_count[2*NDIM];
  int i;

  char *fname = "init_g()";
//printf("%s\n",fname);

  for(i=0; i<2*NDIM;i++){
    local_count[i]=non_local_count[i]=0;
  }
  //Location of gauge field
  IFloat *u = gauge_field_addr;
  if (g_addr) u = g_addr;

  //For staggered parallel transport, we need to re-order the gauge fields
  //to match the ordering of the vector field



  //Send and receive directions
  SCUDir rcv_dir[]={SCU_XP, SCU_XM, SCU_YP, SCU_YM, SCU_ZP, SCU_ZM,SCU_TP,SCU_TM};
  SCUDir snd_dir[]={SCU_XM, SCU_XP, SCU_YM, SCU_YP, SCU_ZM, SCU_ZP,SCU_TM,SCU_TP};

  //Temporary buffer (allocated on cache) that receives an SU(3) matrix
  IFloat *rcv_mat = (IFloat *)Alloc(cname,fname,"rcv_mat",18*sizeof(IFloat),QFAST|QNONCACHE);

  sys_cacheflush(0);

  for(i=0;i<NDIM;i++){
    //Initialize SCUDirArg for sending and receiving the one-hop term
    SCUDirArgIR snd;
    SCUDirArgIR rcv;
    if(!local[i]){
      snd.Init(u,snd_dir[i*2+1],SCU_SEND,sizeof(matrix));
      rcv.Init(rcv_mat,rcv_dir[i*2+1],SCU_REC,sizeof(matrix));
    }

    for(x[3]=0,nei[3]=0;x[3]<size[3];x[3]++,nei[3]++)
      for(x[2]=0,nei[2]=0;x[2]<size[2];x[2]++,nei[2]++)
	for(x[1]=0,nei[1]=0;x[1]<size[1];x[1]++,nei[1]++)
	  for(x[0]=0,nei[0]=0;x[0]<size[0];x[0]++,nei[0]++){
//printf("%d %d %d %d %d\n",i,x[0],x[1],x[2],x[3]);
	    // positive direction
	    //this is a hop in the positive direction, meaning data must be sent
	    //in the negative direction.
	    if((x[i] == 0) && (!local[i]) ){
	      //Calculate the appropriate coordinate on the adjacent node
	      nei[i] = size[i]-1;  
	      //Copy the appropriate matrix from u to uc_nl
	      Copy((uc_nl[2*i]+non_local_count[2*i])->mat, u+LexGauge(nei,i)*GAUGE_LEN);
	      non_local_count[i*2]++;
	      if (non_local_count[i*2]>non_local_chi[i*2])
		fprintf(stderr,"%s:non_local_count[%d](%d)>non_local_chi[%d](%d)\n",
			fname,2*i,non_local_count[2*i],2*i,non_local_chi[2*i]);
	    } else {
	      //Calculate the appropriate neighbor coordinate on the local node
	      nei[i] = (x[i]-1+size[i])%size[i];
	      //Copy from u to uc_l
	      Copy((uc_l[2*i]+local_count[2*i])->mat, u+LexGauge(nei,i)*GAUGE_LEN);
	      local_count[i*2]++;
	      if (local_count[i*2+1]>local_chi[i*2+1])
		fprintf(stderr,"%s:local_count[%d](%d)>local_chi[%d](%d)\n",
			fname,2*i+1,local_count[2*i+1],2*i+1,local_chi[2*i+1]);
	    }
	    // negative direction
	    if((x[i] == (size[i]-1) ) && (!local[i]) ){
	      nei[i] = 0;
	      //Send the appropriate matrix
	      snd.Addr(u+LexGauge(x,i)*GAUGE_LEN);
	      //Send the transmission, prepare to receive
	      snd.StartTrans();rcv.StartTrans();
	      //Complete the send and receive
	      snd.TransComplete();rcv.TransComplete();
	      //Copy to uc_nl from the received matrix
	      DagCopy((uc_nl[2*i+1]+non_local_count[2*i+1])->mat, rcv_mat);
	      non_local_count[i*2+1]++;
	      if (non_local_count[i*2]>non_local_chi[i*2])
		fprintf(stderr,"%s:non_local_count[%d](%d)>non_local_chi[%d](%d)\n",
			fname,2*i,non_local_count[2*i],2*i,non_local_chi[2*i]);
	    } else {
	      //Calculate the appropriate neighbor coordinate on the local volume
	      nei[i] = (x[i]+1)%size[i];
	      //Copy from u to uc_l
	      DagCopy((uc_l[2*i+1]+local_count[2*i+1])->mat, u+LexGauge(x,i)*GAUGE_LEN);
	      local_count[i*2+1]++;
	      if (local_count[i*2+1]>local_chi[i*2+1])
		fprintf(stderr,"%s:local_count[%d](%d)>local_chi[%d](%d)\n",
			fname,2*i+1,local_count[2*i+1],2*i+1,local_chi[2*i+1]);
	    }
	    nei[i] = x[i];
	  } // x[]
  } // i
  //Loop over all possible communication directions
  for(i=0;i<2*NDIM;i++) 
    if (!local[i/2]) {
      for (int hop=1; hop<=MAX_HOP; hop++) {
//printf("%d %d\n",i,hop);
      //Initialize SCUArg to receive fermion fields
      SCUarg[hop-1][i*2] = new SCUDirArgIR;
      SCUarg[hop-1][i*2]->Init((void *)rcv_buf[i],rcv_dir[i],SCU_REC,
			       hop*non_local_chi[i]*VECT_LEN*sizeof(IFloat),1,0,IR_9);
      //Initialize SCUArg to send fermion field
      SCUarg[hop-1][i*2+1] = new SCUDirArgIR;
      SCUarg[hop-1][i*2+1]->Init((void *)rcv_buf[i],snd_dir[i],SCU_SEND,hop*blklen[i],
				 numblk[i],stride[i]+(1-hop)*blklen[i],IR_9);
    
      //Receive for Matrices
      SCUarg_mat[hop-1][i*2] = new SCUDirArgIR;
      SCUarg_mat[hop-1][i*2]->Init((void *)rcv_buf[i],rcv_dir[i],SCU_REC,
				   3*hop*non_local_chi[i]*VECT_LEN*sizeof(IFloat),1,0,IR_9);
      //send for matrices
      SCUarg_mat[hop-1][i*2+1] = new SCUDirArgIR;
      SCUarg_mat[hop-1][i*2+1]->Init((void *)rcv_buf[i],snd_dir[i],SCU_SEND,
				     3*hop*blklen[i],numblk[i],
				     3*(stride[i]+(1-hop)*blklen[i]),IR_9);
      //Receive
      SCUarg2[hop-1][i*2] = new SCUDirArgIR;
      SCUarg2[hop-1][i*2]->Init((void *)rcv_buf2[i],rcv_dir[i],SCU_REC,
				hop*non_local_chi[i]*VECT_LEN*sizeof(IFloat),1,0,IR_9);
      //Send
      SCUarg2[hop-1][i*2+1] = new SCUDirArgIR;
      SCUarg2[hop-1][i*2+1]->Init((void *)rcv_buf2[i],snd_dir[i],SCU_SEND,hop*blklen[i],
				  numblk[i],stride[i]+(1-hop)*blklen[i],IR_9);
      }

      //-----------------------------------------------------------------------
      //Initialize SCUArg to receive fermion fields
      SCUarg_cb[i*2] = new SCUDirArgIR;
//printf("SCUarg_cb\n");
      SCUarg_cb[i*2]->Init((void *)rcv_buf[i],rcv_dir[i],SCU_REC,
			     non_local_chi_cb[i]*VECT_LEN*sizeof(IFloat),1,0,IR_9);

      //Initialize SCUArg to send fermion field
      SCUarg_cb[i*2+1] = new SCUDirArgIR;
//printf("SCUarg_cb\n");
      
      if(i%2)
	SCUarg_cb[i*2+1]->Init((void *)rcv_buf[i],snd_dir[i],SCU_SEND,
			       non_local_chi_cb[i]*VECT_LEN*sizeof(IFloat),1,0,IR_9);
      else 
	SCUarg_cb[i*2+1]->Init((void *)rcv_buf[i],snd_dir[i],SCU_SEND,blklen_cb[i],
				   numblk_cb[i],stride_cb[i],IR_9);
    
      //Receive for Matrices
      SCUarg_mat_cb[i*2] = new SCUDirArgIR;
//printf("SCUarg_mat_cb\n");
	SCUarg_mat_cb[i*2]->Init((void *)rcv_buf[i],rcv_dir[i],SCU_REC,
				   3*non_local_chi_cb[i]*VECT_LEN*sizeof(IFloat),1,0,IR_9);

      //send for matrices
      SCUarg_mat_cb[i*2+1] = new SCUDirArgIR;
//printf("SCUarg_mat_cb\n");
      if(i%2)
	SCUarg_mat_cb[i*2+1]->Init((void *)rcv_buf[i],snd_dir[i],SCU_SEND,
				   3*non_local_chi_cb[i]*VECT_LEN*sizeof(IFloat),1,0,IR_9);
      else
	SCUarg_mat_cb[i*2+1]->Init((void *)rcv_buf[i],snd_dir[i],SCU_SEND,
				   3*blklen_cb[i],numblk_cb[i],3*stride_cb[i],IR_9);
      //-----------------------------------------------------------------------
    }
  

  Free(rcv_mat);
//printf("%s done\n",fname);
}


//End Initialization
//----------------------------------------------------------------------------

//Parallel transport of a matrix defined on one half of the
//checkerboaded lattice
//
//Parameters
//
//n - The number of direction in which to perform the parallel transport
//mout - Result of the parallel transport, on sites with opposite parity of min
//min - Initial field, defined on sites with only one parity
//dir - a list of the n directions in which the field will be transported
//cb - Checkerboard parity of the vector min

#undef PROFILE
void PT::mat_cb(int n, IFloat **mout, IFloat **min, const int *dir, int
parity, IFloat * new_gauge_field)
{
  mat_cb_norm(n,mout,min,dir,parity,new_gauge_field);
}

#undef PROFILE
void PT::mat_cb(int n, IFloat **mout, IFloat **min, const int *dir, int
parity)
{
  mat_cb_norm(n,mout,min,dir,parity,gauge_field_addr);
}

#define PROFILE
#undef PROFILE
void PT::mat_cb_norm(int n, IFloat **mout, IFloat **min, const int *dir, int
parity, IFloat * gauge)
{
  //List of the different directions
  int wire[n];
  int i;

  //SCUDirArgs for sending and receiving in the n directions
  SCUDirArgIR *SCUarg_p[2*n];
  SCUDirArgMulti SCUmulti;
  static int call_num = 0;
  int vlen = VECT_LEN;
  int vlen2 = VECT_LEN;

  call_num++;
  
  //Name our function
  char *fname="pt_mat_cb()";
  //  VRB.Func("",fname);
  
  //Set the transfer directions
  //If wire[i] is even, then we have communication in the negative direction
  //If wire[i] is odd, then we have communication in the positive direction
  for(i=0;i<n;i++)
    wire[i]=dir[i];

#ifdef PROFILE
  Float dtime  = - dclock();
#endif

  //If wire[i] is odd, then we have parallel transport in the
  //positive direction.  In this case, multiplication by the link matrix is
  //done before the field is transferred over to the adjacent node
  //
  //If we have transfer in the negative T direction (wire[i] = 6), then
  //we have to copy the appropriate fields to a send buffer
  for(i=0;i<n;i++)
    {
      if(!local[wire[i]/2])
      {
	if(wire[i]%2)
	  {
	    if(conjugated)
	      pt_cmm_cpp(non_local_chi_cb[wire[i]],(long)uc_nl_cb_pre[parity][wire[i]/2],(long)min[i],(long)snd_buf_cb[wire[i]/2],(long)gauge);
	    else
	      pt_cmm_dag_cpp(non_local_chi_cb[wire[i]],(long)uc_nl_cb_pre[parity][wire[i]/2],(long)min[i],(long)snd_buf_cb[wire[i]/2],(long)gauge);
	  }
	else if((wire[i] == 6))
	  {
	    for(int j = 0; j < non_local_chi_cb[6];j++)
//	      moveMem(snd_buf_t_cb + j*GAUGE_LEN,min[i] + 3 * *(Toffset[parity]+j)*3,GAUGE_LEN*sizeof(IFloat));
	      memcpy(snd_buf_t_cb + j*GAUGE_LEN,min[i] + 3 * *(Toffset[parity]+j)*3,GAUGE_LEN*sizeof(IFloat));
	  }
      }
    }

  int non_local_dir=0;
  for(i=0;i<n;i++)
    if(!local[wire[i]/2])
    {
      //Calculate the starting address for the data to be sent
      IFloat *addr = min[i] + GAUGE_LEN * offset_cb[wire[i]];
      //This points to the appropriate SCUDirArg for receiving
      SCUarg_p[2*non_local_dir] = SCUarg_mat_cb[2*wire[i]];
      //This points to the appropriate SCUDirArg for sending
      SCUarg_p[2*i+non_local_dir] = SCUarg_mat_cb[2*wire[i]+1];
      
      //Set the send address
      if(wire[i]%2)
	SCUarg_p[2*non_local_dir+1]->Addr((void *)snd_buf_cb[wire[i]/2]);
      else if(wire[i] == 6)
	SCUarg_p[2*non_local_dir+1]->Addr((void *)snd_buf_t_cb);
      else
	SCUarg_p[2*non_local_dir+1]->Addr((void *)addr);
      non_local_dir++;
    }

  if(non_local_dir){
    SCUmulti.Init(SCUarg_p,2*non_local_dir);

//Begin transmission
    SCUmulti.SlowStartTrans();

//End transmission
    SCUmulti.TransComplete();
  }

  //Do local calculations
  for(i=0;i<n;i++)
    {
      if((wire[i]%2 && conjugated) || ((wire[i]%2 == 0) && (conjugated == 0)))
	pt_cmm_cpp(local_chi_cb[wire[i]],(long)uc_l_cb[parity][wire[i]],(long)min[i],(long)mout[i],(long)gauge);
      else
	pt_cmm_dag_cpp(local_chi_cb[wire[i]],(long)uc_l_cb[parity][wire[i]],(long)min[i],(long)mout[i],(long)gauge);
    }

  //If wire[i] is even, then we have transport in the negative direction
  //In this case, the vector field is multiplied by the SU(3) link matrix
  //after all communication is complete
  IFloat *fp0,*fp1;
  for(i=0;i<n;i++)
    {
      if(!local[wire[i]/2])
      	{
	  if(!(wire[i]%2))
	    {
	      if(conjugated)
		pt_cmm_dag_cpp(non_local_chi_cb[wire[i]],(long)uc_nl_cb[parity][wire[i]],(long)rcv_buf[wire[i]],(long)mout[i],(long)gauge);
	      else
		pt_cmm_cpp(non_local_chi_cb[wire[i]],(long)uc_nl_cb[parity][wire[i]],(long)rcv_buf[wire[i]],(long)mout[i],(long)gauge);
	    }
	  //Otherwise we have parallel transport in the positive direction.
	  //In this case, the received data has already been pre-multiplied
	  //All we need to do is to put the transported field in the correct place
	  else
	    {
	      //int destination, source;
	      //Place the data in the receive buffer into the result vector
	      for(int s=0;s<non_local_chi_cb[wire[i]];s++)
		{
		  //source = uc_nl_cb[parity][wire[i]][s].src;
		  fp0 = (IFloat *)((long)rcv_buf[wire[i]]+3*uc_nl_cb[parity][wire[i]][s].src);
		  //destination = uc_nl_cb[parity][wire[i]][s].dest;
		  fp1 = (IFloat *)(mout[i]+3*uc_nl_cb[parity][wire[i]][s].dest);
		  //for(int d = 0;d<GAUGE_LEN;d++)
		  //*(fp1+d) = *(fp0+d);
//		  moveMem(fp1,fp0,GAUGE_LEN*sizeof(IFloat));
		  memcpy(fp1,fp0,GAUGE_LEN*sizeof(IFloat));
		}
	    }
	}
    }
#ifdef PROFILE
  dtime +=dclock();
  print_flops("",fname,99*vol*n,dtime);
#endif
//  ParTrans::PTflops +=99*n*vol;
}

//Parallel transport of a vector defined on single parity sites
//
//Parameters
//
//n - number of directions in which to parallel transport
//vout - Transported vector
//vin - Initial vector
//dir - list of directions in which to transport the vectors
//cb - Parity of the sites where the vectors are defined
//gauge - Pointer to block of gauge fields in STAG order

#ifndef SCIDAC 

//Normal parallel transport with normal gauge fields
#undef PROFILE
void PT::vec_cb(int n, IFloat **vout, IFloat **vin, const int *dir, int
 parity)
{
  vec_cb_norm(n,vout,vin,dir,parity,gauge_field_addr);
}

//Normal parallel transport, but with user-specified gauge fields
#undef PROFILE
void PT::vec_cb(int n, IFloat **vout, IFloat **vin, const int *dir, int
parity, IFloat * new_gauge_field)
{
  vec_cb_norm(n,vout,vin,dir,parity,new_gauge_field);
}

//Padded parallel transport with normal gauge fields
#undef PROFILE
void PT::vec_cb(int n, IFloat *vout, IFloat **vin, const int *dir, int
parity, int pad)
{
  vec_cb_pad(n,vout,vin,dir,parity,gauge_field_addr);
}

//Padded parallel transport, but with user-specified gauge fields
#undef PROFILE
void PT::vec_cb(int n, IFloat *vout, IFloat **vin, const int *dir, int
parity, int pad, IFloat * new_gauge_field)
{
  vec_cb_pad(n,vout,vin,dir,parity,new_gauge_field);
}

#define PROFILE
#undef PROFILE
void PT::vec_cb_norm(int n, IFloat **vout, IFloat **vin, const int *dir,int parity, IFloat * gauge)
{
  //List of the different directions
  int wire[n];
  int i;
//  int j,d,s,k;
  //SCUDirArgs for sending and receiving in the n directions
  SCUDirArgIR *SCUarg_p[2*non_local_dirs];
  //SCUDirArgIR *SCUarg_p[2*n];
  SCUDirArgMulti SCUmulti;
  static int call_num = 0;
  int vlen = VECT_LEN;
  int vlen2 = VECT_LEN;
//  printf("gauge=%p\n",gauge);

  call_num++;
  
  //Name our function
//  char *fname="pt_1vec_cb_norm()";
  
  //Set the transfer directions
  //If wire[i] is even, then we have communication in the negative direction
  //If wire[i] is odd, then we have communication in the positive direction
  for(i=0;i<n;i++)
    wire[i]=dir[i];

  Float dtime;


  //If wire[i] is odd, then we have parallel transport in the
  //positive direction.  In this case, the matrix multiplication is
  //done before the field is transferred over to the adjacent node
  //
  //If we have transfer in the negative T direction (wire[i] = 6) then
  //we have to copy the appropriate fields into the send buffer
  if(conjugated)
    for(i=0;i<n;i++)
      {
	if(!local[wire[i]/2])
	  {
	    if(wire[i]%2)
	      {
		//printf("dir = %d, pre-mulitply\n", wire[i]);
#ifdef PROFILE
  dtime  = - dclock();
#endif

  partrans_cmv(non_local_chi_cb[wire[i]]/2,uc_nl_cb_pre[parity][wire[i]/2],gauge,vin[i],snd_buf_cb[wire[i]/2]);

#ifdef PROFILE
  dtime +=dclock();
  print_flops("",fname,66*non_local_chi_cb[wire[i]],dtime);
#endif
	      }
	    else if((wire[i] == 6))
	      {
#ifdef PROFILE
  dtime  = - dclock();
#endif
#if 1
            pt_copy_buffer(non_local_chi_cb[6],(long)vin[i],(long)snd_buf_t_cb,(long)Toffset[parity]);
#else
		for(j = 0; j < non_local_chi_cb[6];j++)
		  for(k = 0; k < VECT_LEN;k++)
		    *(snd_buf_t_cb+j*VECT_LEN+k) = *(vin[i] + *(Toffset[parity]+j)+ k);
		  //moveMem(snd_buf_t_cb + j*VECT_LEN,vin[i] + *(Toffset[parity]+j)*vlen,VECT_LEN*sizeof(IFloat));
#endif
#ifdef PROFILE
  dtime +=dclock();
  print_flops(fname,"pt_copy_buffer()",0,dtime);
#endif
	      }
	  }
      }
  else
    for(i=0;i<n;i++)
      {
	if(!local[wire[i]/2])
	  {
	    if(wire[i]%2)
	      {
#ifdef PROFILE
  dtime  = - dclock();
#endif
 
  partrans_cmv_dag(non_local_chi_cb[wire[i]]/2,uc_nl_cb_pre[parity][wire[i]/2],gauge,vin[i],snd_buf_cb[wire[i]/2]);	 

#ifdef PROFILE
  dtime +=dclock();
  print_flops("",fname,66*non_local_chi_cb[wire[i]],dtime);
#endif
	      }
	    else if(wire[i] == 6)
	      {
#ifdef PROFILE
  dtime  = - dclock();
#endif
#if 1
            pt_copy_buffer(non_local_chi_cb[6],(long)vin[i],(long)snd_buf_t_cb,(long)Toffset[parity]);
#else
		for(j = 0; j < non_local_chi_cb[6];j++)
		  for(k = 0; k < VECT_LEN;k++)
		    *(snd_buf_t_cb+j*VECT_LEN+k) = *(vin[i] + *(Toffset[parity]+j)+ k);
//		  moveMem(snd_buf_t_cb + j*VECT_LEN,vin[i] + *(Toffset[parity]+j),VECT_LEN*sizeof(IFloat));
#endif
#ifdef PROFILE
  dtime +=dclock();
  print_flops(fname,"pt_copy_buffer()",0,dtime);
#endif
	      }
	  }
      }
#ifdef PROFILE
  dtime  = - dclock();
#endif

  #if 1
  int comms = 0;
  for(i=0;i<n;i++)
    {
      if(!local[wire[i]/2])
	{
	  //Calculate the starting address for the data to be sent
	  IFloat *addr = vin[i] + VECT_LEN * offset_cb[wire[i]];
	  //This points to the appropriate SCUDirArg for receiving
	  SCUarg_p[2*comms] = SCUarg_cb[2*wire[i]];
	  //This points to the appropriate SCUDirArg for sending
	  SCUarg_p[2*comms+1] = SCUarg_cb[2*wire[i]+1];
	  
	  //Set the send address
	  if(wire[i]%2)
	    SCUarg_p[2*comms+1]->Addr((void *)snd_buf_cb[wire[i]/2]);
	  else if(wire[i] == 6)
	    SCUarg_p[2*comms+1]->Addr((void *)snd_buf_t_cb);
	  else
	    SCUarg_p[2*comms+1]->Addr((void *)addr);
	  comms++;
	}
    }
  #endif


  if(comms){
    SCUmulti.Init(SCUarg_p,2*comms);
//Begin transmission
    SCUmulti.SlowStartTrans();
  }

  //Do local calculations
  if(conjugated)
    {
      for(i=0;i<n;i++)
	{
#ifdef PROFILE
  dtime  = - dclock();
#endif 
	
  if(wire[i]%2)
    partrans_cmv(local_chi_cb[wire[i]]/2,uc_l_cb[parity][wire[i]],gauge,vin[i],vout[i]);
  else
    partrans_cmv_dag(local_chi_cb[wire[i]]/2,uc_l_cb[parity][wire[i]],gauge,vin[i],vout[i]);
  
#ifdef PROFILE
  dtime +=dclock();
  print_flops("",fname,66*local_chi_cb[wire[i]],dtime);
#endif
	}
    }
  else
    {
    for(i=0;i<n;i++)
      {
#ifdef PROFILE
  dtime  = - dclock();
#endif

  if(!(wire[i]%2))
    partrans_cmv(local_chi_cb[wire[i]]/2,uc_l_cb[parity][wire[i]],gauge,vin[i],vout[i]);
  else
    partrans_cmv_dag(local_chi_cb[wire[i]]/2,uc_l_cb[parity][wire[i]],gauge,vin[i],vout[i]);

#ifdef PROFILE
  dtime +=dclock();
  print_flops("",fname,66*local_chi_cb[wire[i]],dtime);
#endif
      }
    }
  
  //End transmission
  if(comms){ SCUmulti.TransComplete(); }

  //If wire[i] is even, then we have transport in the negative direction.
  //In this case, the vector field is multiplied by the SU(3) link matrix
  //after all communication is complete
  IFloat *fp0, *fp1;
  for(i=0;i<n;i++)
    {
      if(!local[wire[i]/2])
      	{
	  if(!(wire[i]%2))
	    {
#ifdef PROFILE
  dtime  = - dclock();
#endif

	    if(conjugated)
	      partrans_cmv_dag(non_local_chi_cb[wire[i]]/2,uc_nl_cb[parity][wire[i]],gauge,rcv_buf[wire[i]],vout[i]);
	    else
	      partrans_cmv(non_local_chi_cb[wire[i]]/2,uc_nl_cb[parity][wire[i]],gauge,rcv_buf[wire[i]],vout[i]);

#ifdef PROFILE
  dtime +=dclock();
  print_flops("",fname,66*non_local_chi_cb[wire[i]],dtime);
#endif
	    }
	  //Otherwise we have parallel transport in the positive direction.
	  //In this case, the received data has already been pre-multiplied
	  //All we need to do is to put the transported field in the correct place
	  else
	    {
#ifdef PROFILE
  dtime  = - dclock();
#endif
#if 1
              pt_copy(non_local_chi_cb[wire[i]]/2,uc_nl_cb[parity][wire[i]],rcv_buf[wire[i]],vout[i]);
#else
	      //Place the data in the receive buffer into the result vector
	      for(s=0;s<non_local_chi_cb[wire[i]];s++)
		{
		  fp0 = (IFloat *)((long)rcv_buf[wire[i]]+uc_nl_cb[parity][wire[i]][s].src);
		  fp1 = (IFloat *)((long)vout[i]+uc_nl_cb[parity][wire[i]][s].dest);
		  for(d = 0;d<VECT_LEN;d++)
		    *(fp1+d) = *(fp0+d);
		  //moveMem(fp1,fp0,VECT_LEN*sizeof(IFloat));
		}
#endif
#ifdef PROFILE
  dtime +=dclock();
  print_flops(fname,"pt_copy()",0,dtime);
#endif
	    }
	}
    }
//  ParTrans::PTflops +=33*n*vol;
}

#define PROFILE
#undef PROFILE

void PT::vec_cb_pad(int n, IFloat *vout, IFloat **vin, const int *dir,int parity, IFloat * gauge)
{
  //List of the different directions
  int wire[n];
  int i;
  //SCUDirArgs for sending and receiving in the n directions
  SCUDirArgIR *SCUarg_p[2*non_local_dirs];
  //SCUDirArgIR *SCUarg_p[2*n];
  SCUDirArgMulti SCUmulti;
  static int call_num = 0;
//  int vlen = VECT_LEN;
//  int vlen2 = 8;
#ifdef PROFILE
  printf("gauge=%p parity =%d\n",gauge,parity);
  for(i=0;i<n;i++){
    printf("%d: vin=%p vout=%p\n",i,vin[i],vout);
  }
#endif

  call_num++;
  
  //Name our function
//  char *fname="pt_1vec_cb_pad()";
  //VRB.Func("",fname);
  
  //Set the transfer directions
  //If wire[i] is even, then we have communication in the negative direction
  //If wire[i] is odd, then we have communication in the positive direction
  for(i=0;i<n;i++)
    wire[i]=dir[i];

  Float dtime;

  //If wire[i] is odd, then we have parallel transport in the
  //positive direction.  In this case, the matrix multiplication is
  //done before the field is transferred over to the adjacent node
  //
  //If we have transfer in the negative T direction (wire[i] = 6) then
  //we have to copy the appropriate fields into the send buffer
  for(i=0;i<n;i++)
    {
      if(!local[wire[i]/2])
      	{
	  if(wire[i]%2)
	    {
	      //printf("dir = %d, pre-mulitply \n", wire[i]);
#ifdef PROFILE
  dtime  = - dclock();
#endif

  if(conjugated)
    {
      partrans_cmv(non_local_chi_cb[wire[i]]/2,uc_nl_cb_pre[parity][wire[i]/2],gauge,vin[i],snd_buf_cb[wire[i]/2]);
    }
  else
    partrans_cmv_dag(non_local_chi_cb[wire[i]]/2,uc_nl_cb_pre[parity][wire[i]/2],gauge,vin[i],snd_buf_cb[wire[i]/2]);
  
#ifdef PROFILE
  dtime +=dclock();
  print_flops("",fname,66*non_local_chi_cb[wire[i]],dtime);
#endif
	    }
	  else if(wire[i] == 6)
	    {
#ifdef PROFILE
  dtime  = - dclock();
#endif
#if 1
            pt_copy_buffer(non_local_chi_cb[6],(long)vin[i],(long)snd_buf_t_cb,(long)Toffset[parity]);
#else
	      for(int j = 0; j < non_local_chi_cb[6];j++)
		  for(k = 0; k < VECT_LEN;k++)
		    *(snd_buf_t_cb+j*VECT_LEN+k) = *(vin[i] + *(Toffset[parity]+j)+ k);
#endif
#ifdef PROFILE
  dtime +=dclock();
  print_flops(fname,"pt_copy_buffer()",0,dtime);
#endif
	    }
	}
    }

#ifdef PROFILE
  dtime  = - dclock();
#endif
  int comms = 0;
  for(i=0;i<n;i++)
    {
      if(!local[wire[i]/2])
	{
	  //Calculate the starting address for the data to be sent
	  IFloat *addr = vin[i] + VECT_LEN * offset_cb[wire[i]];
	  //This points to the appropriate SCUDirArg for receiving
	  SCUarg_p[2*comms] = SCUarg_cb[2*wire[i]];
	  //This points to the appropriate SCUDirArg for sending
	  SCUarg_p[2*comms+1] = SCUarg_cb[2*wire[i]+1];
	  
	  //Set the send address
	  if(wire[i]%2)
	    SCUarg_p[2*comms+1]->Addr((void *)snd_buf_cb[wire[i]/2]);
	  else if(wire[i] == 6)
	    SCUarg_p[2*comms+1]->Addr((void *)snd_buf_t_cb);
	  else
	    SCUarg_p[2*comms+1]->Addr((void *)addr);
	  comms++;
	}
    }
#ifdef PROFILE
  dtime +=dclock();
  print_flops(fname,"Addr",0,dtime);
#endif

#ifdef PROFILE
  dtime  = - dclock();
#endif
  if(comms){
    SCUmulti.Init(SCUarg_p,2*comms);
//Begin transmission
    SCUmulti.SlowStartTrans();
  }
#ifdef PROFILE
  dtime +=dclock();
  print_flops(fname,"StartTrans()",0,dtime);
#endif


  //Do local calculations
  for(i=0;i<n;i++)
    {
#ifdef PROFILE
  dtime  = - dclock();
#endif

      if((wire[i]%2 && conjugated) || ((wire[i]%2 == 0) && (conjugated == 0)))
	{
	partrans_cmv_pad(local_chi_cb[wire[i]]/2,uc_l_pad_cb[parity][wire[i]],gauge,vin[i],vout);
	}
      else
	partrans_cmv_dag_pad(local_chi_cb[wire[i]]/2,uc_l_pad_cb[parity][wire[i]],gauge,vin[i],vout);

#ifdef PROFILE
  dtime +=dclock();
  print_flops("",fname,66*local_chi_cb[wire[i]],dtime);
#endif
    }
#ifdef PROFILE
  dtime  = - dclock();
#endif
  if(comms){ SCUmulti.TransComplete(); }
#ifdef PROFILE
  dtime +=dclock();
  print_flops(fname,"TransComplete()",0,dtime);
#endif

  //If wire[i] is even, then we have transport in the negative direction.
  //In this case, the vector field is multiplied by the SU(3) link matrix
  //after all communication is complete
//  IFloat *fp0,*fp1;
  for(i=0;i<n;i++)
    {
      if(!local[wire[i]/2])
	{
	  if(!(wire[i]%2))
	    {
#ifdef PROFILE
  dtime  = - dclock();
#endif
 
  if(conjugated)
    partrans_cmv_dag_pad(non_local_chi_cb[wire[i]]/2,uc_nl_pad_cb[parity][wire[i]],gauge,rcv_buf[wire[i]],vout);
  else
    partrans_cmv_pad(non_local_chi_cb[wire[i]]/2,uc_nl_pad_cb[parity][wire[i]],gauge,rcv_buf[wire[i]],vout);

#ifdef PROFILE
  dtime +=dclock();
  print_flops("",fname,66*non_local_chi_cb[wire[i]],dtime);
#endif
	    }
	  //Otherwise we have parallel transport in the positive direction.
	  //In this case, the received data has already been pre-multiplied
	  //All we need to do is to put the transported field in the correct place
	  else
	    {
#ifdef PROFILE
  dtime  = - dclock();
#endif
#if 1
              pt_copy_pad(non_local_chi_cb[wire[i]]/2,uc_nl_pad_cb[parity][wire[i]],rcv_buf[wire[i]],vout);
#else
	      //Place the data in the receive buffer into the result vector
	      for(int s=0;s<non_local_chi_cb[wire[i]];s++)
		{
		  fp0 = (IFloat *)((long)rcv_buf[wire[i]]+uc_nl_pad_cb[parity][wire[i]][s].src);
		  fp1 = (IFloat *)((long)vout +  uc_nl_pad_cb[parity][wire[i]][s].dest);
		  for(int d = 0;d<VECT_LEN;d++)
		    *(fp1+d) = *(fp0+d);
		  //moveMem(fp1,fp0,VECT_LEN*sizeof(IFloat));
		}
#endif
#ifdef PROFILE
  dtime +=dclock();
  print_flops(fname,"pt_copy_pad()",0,dtime);
#endif
	    }
	}
    }
//  ParTrans::PTflops +=33*n*vol;
}

#endif // #ifndef SCIDAC

//-----------------------------------------------------------------------------

//Parallel transport of a matrix. through one hop.
//The matrix min is parallel transported and the result is placed in mout
#undef PROFILE
void PT::mat(int n, matrix **mout, matrix **min, const int *dir){
    
  int wire[n];
  int i;
  SCUDirArgIR *SCUarg_p[2*n];
  SCUDirArgMulti SCUmulti;
  static int call_num = 0;

  call_num++;
//  char *fname="pt_mat()";
//  VRB.Func("",fname);
  
  for(i=0;i<n;i++) wire[i] = dir[i]; 
#ifdef PROFILE
  Float dtime  = - dclock();
#endif
  int non_local_dir=0;
  for(i=0;i<n;i++)
  if (!local[wire[i]/2]) {
    //Calculate the address for transfer in a particular direction
    Float * addr = ((Float *)min[i]+GAUGE_LEN*offset[wire[i]]);
    //This should point to the appropriate SCUDirArg for receiving
    SCUarg_p[2*non_local_dir] = SCUarg_mat[0][2*wire[i]];
    //This points to the appropriate SCUDirArg for sending
    SCUarg_p[2*non_local_dir+1] = SCUarg_mat[0][2*wire[i]+1];
    //Reset the send address
    SCUarg_p[2*non_local_dir+1]->Addr((void *)addr);
    non_local_dir++;
  }
if (non_local_dir){
  SCUmulti.Init(SCUarg_p,non_local_dir*2);
  //Start transmission
  SCUmulti.SlowStartTrans();
}
  //Interleaving of local computation of matrix multiplication
  for(i=0;i<n;i++){
    partrans_cmm_agg(uc_l[wire[i]],min[i],mout[i],local_chi[wire[i]]/2);
  }

  if (non_local_dir)
  SCUmulti.TransComplete();
  //Do non-local computations
  for(i=0;i<n;i++) 
  if (!local[wire[i]/2]) {
    partrans_cmm_agg(uc_nl[wire[i]],(matrix *)rcv_buf[wire[i]],mout[i],non_local_chi[wire[i]]/2);
  }
#ifdef PROFILE
  dtime +=dclock();
  print_flops("",fname,198*vol*n,dtime);
#endif
//  ParTrans::PTflops +=198*n*vol;
}


#undef PROFILE
//Parallel transport of a vector through one hop
void PT::vec(int n, IFloat **vout, IFloat **vin, const int *dir){
  int i;
  static int call_num=0;
  SCUDirArgIR *SCUarg_p[2*n];
  call_num++;
  //for(int s = 0; s < GJP.VolNodeSites(); s++)
  //  {
  //    for(int t = 0; t < 4; t++)
  //	{
  //	  printf("site = %d, direction = %d\n",s,t);
  //	  for(int u = 0; u < 9; u++)
  //	    printf("%e %e\n",*(gauge_field_addr+4*GAUGE_LEN*s + GAUGE_LEN*t + 2*u),*(gauge_field_addr+4*GAUGE_LEN*s + GAUGE_LEN*t + 2*u+1));
  //	}
  //  }

#ifdef PROFILE
  Float dtime  = - dclock();
#endif
  int wire[n];
  SCUDirArgMulti SCUmulti;

  char *fname="pt_1vec";
//  VRB.Func("",fname);
	
  int non_local_dir=0;
  for(i=0;i<n;i++) wire[i] = dir[i]; // from (x,y,z,t) to (t,x,y,z)
//  for(i=0;i<n;i++) printf("wire[%d]=%d\n",i,dir[i]);
  for(i=0;i<n;i++)
  if (!local[wire[i]/2]){
    IFloat * addr = (vin[i]+VECT_LEN*offset[wire[i]]);
    SCUarg_p[2*non_local_dir] = SCUarg[0][2*wire[i]];
    SCUarg_p[2*non_local_dir+1] = SCUarg[0][2*wire[i]+1];
    SCUarg_p[2*non_local_dir+1]->Addr((void *)addr);
    non_local_dir++;
  }
  if(non_local_dir){
    SCUmulti.Init(SCUarg_p,non_local_dir*2);
    SCUmulti.SlowStartTrans();
  }
	
  for(i=0;i<n;i++) 
    partrans_cmv_agg(local_chi[wire[i]],(long)uc_l[wire[i]], (long)vin[i],(long)vout[i]);
	
  if(non_local_dir){ SCUmulti.TransComplete(); }

  for(i=0;i<n;i++) 
    partrans_cmv_agg(non_local_chi[wire[i]],(long)uc_nl[wire[i]], (long)rcv_buf[wire[i]],(long)vout[i]);

#ifdef PROFILE
  dtime +=dclock();
  print_flops("",fname,66*n*vol,dtime);
#endif
  Flops +=66*n*vol;
}

/*! 
  Computes sum[x] = vect[x] vect[x + hop dir]^dagger
  where the sum is over n_vect vectors and the hop is in a forward direction.
*/
void PT::vvpd(IFloat **vect, int n_vect, const int *dir, 
	     int n_dir, int hop, IFloat **sum){

#define NEW_VVPD
  //#undef NEW_VVPD
  //---------------------------------------------------------------------
  //Adapt old vvpd for usage with new interface

#ifdef NEW_VVPD
  //Convert direction array
  int newdir[n_dir];
  for(int i = 0; i < n_dir; i++)
    newdir[i] = 2*dir[i];
  IFloat ***vect_shift = (IFloat ***)FastAlloc("","","vect_shift",n_vect*sizeof(IFloat**));
  for(int i = 0; i < n_vect; i++)
    {
      vect_shift[i] = (IFloat**)FastAlloc("","","vect_shift[i]",n_dir*sizeof(IFloat *));
      for(int j = 0; j < n_dir; j++)
	vect_shift[i][j] = vect[i];
    }
  vvpd(vect, vect_shift, n_vect, newdir, n_dir, hop, sum, 1);
  for(int i = 0; i < n_vect; i++)
    Free(vect_shift[i]);
  Free(vect_shift);
  //----------------------------------------------------------------------
  //Old vvpd
#else
  char *fname = "pt_vvpd()";
//  VRB.Func("",fname);
  int i, v;
  Float f = 2.0;
  int wire[n_dir];
  for(i=0;i<n_dir;i++) wire[i] = dir[i]; // from (x,y,z,t) to (t,x,y,z)

  #ifdef TESTING
  printf("vvpd called.  Checking input data.\n");
  for(int kk = 0; kk < 1; kk++)
  for(int count = 0; count < 6*vol; count++)
    printf("vect[%d][%d]=%f\n",kk,count,(Float)vect[kk][count]);
  printf("End input data check.\n");
  #endif

  SCUDirArgIR *SCUarg_p[2*n_dir];  
  SCUDirArgIR *SCUarg_p2[2*n_dir];  

  // Only do communication in forward direction
  int comms=0;
  for(i=0;i<n_dir;i++)
  if( !local[wire[i]]) {
    if ( size[wire[i]] <hop)
      fprintf(stderr, 
		"%s::size(%d) in direction %d is smaller than the hop(%d)\n",
		fname,size[wire[i]],wire[i],hop);
    SCUarg_p[2*comms] = SCUarg[hop-1][4*wire[i]];
    SCUarg_p[2*comms+1] = SCUarg[hop-1][4*wire[i]+1];
    SCUarg_p2[2*comms] = SCUarg2[hop-1][4*wire[i]];
    SCUarg_p2[2*comms+1] = SCUarg2[hop-1][4*wire[i]+1];
    comms++;
  }

  for(v=0; v<n_vect; v++){
    SCUDirArgMulti SCUmulti;

    if (v%2==0) {
      comms=0;
      for(i=0;i<n_dir;i++)
        if( !local[wire[i]]){ 
	  SCUarg_p[2*comms+1]->Addr((void *)(vect[v]+VECT_LEN*set_offset(2*wire[i], hop)));
          comms++;
        }

      // Start communication
      if (comms) SCUmulti.Init(SCUarg_p,2*comms);
    } else {
      comms=0;
      for(i=0;i<n_dir;i++)
        if( !local[wire[i]]){ 
	  SCUarg_p2[2*comms+1]->Addr((void *)(vect[v]+VECT_LEN*set_offset(2*wire[i], hop)));
          comms++;
      }
      // Start communication
      if (comms) SCUmulti.Init(SCUarg_p2,2*comms);
    } 

    if (comms) SCUmulti.SlowStartTrans();
    // Finalise communication
    if (comms) SCUmulti.TransComplete();

    // Perform non-local calculation for previous v
    if (v>0)
      if (v==1) {
	for(i=0; i<n_dir; i++) 
	  if(non_local_chi[2*wire[i]] > 0)
	    cross_over_lin(sum[i], &f, vect[v-1],rcv_buf[2*wire[i]], hop*non_local_chi[2*wire[i]],
		src_nl[hop-1][2*wire[i]], dest_nl[hop-1][2*wire[i]]);
      } else if (v%2==1) {
	for(i=0; i<n_dir; i++) 
	  if(non_local_chi[2*wire[i]] > 0)
	    cross_lin(sum[i], &f, vect[v-1],rcv_buf[2*wire[i]], hop*non_local_chi[2*wire[i]],
		src_nl[hop-1][2*wire[i]], dest_nl[hop-1][2*wire[i]]);
      } else {
	for(i=0; i<n_dir; i++) 
	  if(non_local_chi[2*wire[i]] > 0)
	    cross_lin(sum[i], &f,vect[v-1],rcv_buf2[2*wire[i]], hop*non_local_chi[2*wire[i]],
		src_nl[hop-1][2*wire[i]], dest_nl[hop-1][2*wire[i]]);
      }
    
    // Perform local calculation for current v
    if (v==0)
      for(i=0; i<n_dir; i++)
	{
	  #ifdef TESTING
	  printf("wire[%d] = %d\n",i,wire[i]);
	  printf("sum[%d] = %f\n",i,(float)*(sum[i]));
	  printf("vol-hop*non_local_chi[%d]=%d\n",2*wire[i],vol-hop*non_local_chi[2*wire[i]]);
	  for(int count = 0; count < vol-hop*non_local_chi[2*wire[i]]; count++)
	    {
	      printf("src_l[%d][%d][%d] = %ld\n",hop-1,2*wire[i],count,(int)src_l[hop-1][2*wire[i]][count]);
	      printf("dest_l[%d][%d][%d] = %ld\n",hop-1,2*wire[i],count,(int)dest_l[hop-1][2*wire[i]][count]);
	      for(int v_count = 0; v_count < 6; v_count++)
		{
		  printf("vect[%d][%d] = %f\n",v,(6*((int)src_l[hop-1][2*wire[i]][count])+v_count),(Float)(vect[v][6*((int)src_l[hop-1][2*wire[i]][count])+v_count]));
		  printf("vect[%d][%d] = %f\n",v,(6*((int)dest_l[hop-1][2*wire[i]][count])+v_count),(Float)(vect[v][(6*((int)dest_l[hop-1][2*wire[i]][count])+v_count)]));
		}
	    }
	  printf("cross_over_look called\n");
	  #endif
	  if((vol-hop*non_local_chi[2*wire[i]]) > 0)
	    cross_over_look(sum[i], &f, vect[v], vect[v], vol-hop*non_local_chi[2*wire[i]], src_l[hop-1][2*wire[i]], dest_l[hop-1][2*wire[i]]);
        }
    else
      {
      for(i=0; i<n_dir; i++)
	if((vol-hop*non_local_chi[2*wire[i]])> 0)
	  cross_look(sum[i], &f, vect[v], vect[v], vol-hop*non_local_chi[2*wire[i]], src_l[hop-1][2*wire[i]], dest_l[hop-1][2*wire[i]]);
      }

  }

  if (v==1) {
    for(i=0; i<n_dir; i++) 
      if(non_local_chi[2*wire[i]] > 0)
	cross_over_lin(sum[i], &f, vect[v-1],rcv_buf[2*wire[i]], hop*non_local_chi[2*wire[i]],
	    src_nl[hop-1][2*wire[i]], dest_nl[hop-1][2*wire[i]]);
  } else if (v%2==1) {
    for(i=0; i<n_dir; i++) 
      if(non_local_chi[2*wire[i]] > 0)
	cross_lin(sum[i], &f, vect[v-1],rcv_buf[2*wire[i]], hop*non_local_chi[2*wire[i]],
		  src_nl[hop-1][2*wire[i]], dest_nl[hop-1][2*wire[i]]);
  } else {
    for(i=0; i<n_dir; i++)
      if(non_local_chi[2*wire[i]] > 0)
	cross_lin(sum[i], &f,vect[v-1],rcv_buf2[2*wire[i]], hop*non_local_chi[2*wire[i]],
		  src_nl[hop-1][2*wire[i]], dest_nl[hop-1][2*wire[i]]);
  }  
//  ParTrans::PTflops += 90*n_vect*n_dir*vol;
#endif
  //------------------------------------------------------------------------
}

/*! 
  Computes sum[x] = vect2[x] vect[x + hop dir]^dagger
  where the sum is over n_vect vectors and the hop is in a forward direction.
*/
void PT::vvpd(IFloat **vect2, IFloat ***vect, int n_vect, const int *dir, int n_dir, int hop, IFloat **sum, int overwrite){

  char *fname = "pt_vvpd()";
//  VRB.Func("",fname);
  int i, s, v;
  Float f = 2.0;
  int wire[n_dir];
  for(i=0;i<n_dir;i++) wire[i] = dir[i]; // from (x,y,z,t) to (t,x,y,z)

  #ifdef TESTING
  for(i = 0; i < n_dir; i++)
    {
      printf("wire[%d] = %d\n",i,wire[i]);
      for(int count = 0; count < vol - hop*non_local_chi[wire[i]]; count++)
	{
	  printf("src_l[%d][%d][%ld] = %d\n",hop-1,wire[i],count,src_l[hop-1][wire[i]][count]);
	  printf("dest_l[%d][%d][%ld] = %d\n",hop-1,wire[i],count,dest_l[hop-1][wire[i]][count]);
	}
     for(int count = 0; count < hop*non_local_chi[wire[i]]; count++)
	{
	  printf("src_nl[%d][%d][%ld] = %d\n",hop-1,wire[i],count,src_nl[hop-1][wire[i]][count]);
	  printf("dest_nl[%d][%d][%ld] = %d\n",hop-1,wire[i],count,dest_nl[hop-1][wire[i]][count]);
	}
    }
  #endif

  SCUDirArgIR *SCUarg_p[2*n_dir];  
  SCUDirArgIR *SCUarg_p2[2*n_dir];  

  //Setup communciation
  int comms=0;
  for(i=0;i<n_dir;i++)
  if( !local[wire[i]/2]) {
    if ( size[wire[i]/2] <hop)
      fprintf(stderr, 
		"%s:size(%d) in direction %d is smaller than the hop(%d)\n",
		fname,size[wire[i]],wire[i],hop);
    SCUarg_p[2*comms] = SCUarg[hop-1][2*wire[i]];
    SCUarg_p[2*comms+1] = SCUarg[hop-1][2*wire[i]+1];
    SCUarg_p2[2*comms] = SCUarg2[hop-1][2*wire[i]];
    SCUarg_p2[2*comms+1] = SCUarg2[hop-1][2*wire[i]+1];
    comms++;
  }

  for(v=0; v<n_vect; v++){
    SCUDirArgMulti SCUmulti;

    if (v%2==0) {
      comms=0;
      for(i=0;i<n_dir;i++)
        if( !local[wire[i]/2]){ 
	  SCUarg_p[2*comms+1]->Addr((void *)(vect[v][i]+VECT_LEN*set_offset(wire[i], hop)));
          comms++;
        }

      // Start communication
      if (comms) SCUmulti.Init(SCUarg_p,2*comms);
    } else {
      comms=0;
      for(i=0;i<n_dir;i++)
        if( !local[wire[i]/2]){ 
	  SCUarg_p2[2*comms+1]->Addr((void *)(vect[v][i]+VECT_LEN*set_offset(wire[i], hop)));
          comms++;
      }

      // Start communication
      if (comms) SCUmulti.Init(SCUarg_p2,2*comms);
    }
    if (comms) SCUmulti.SlowStartTrans();
    // Finalise communication
    if (comms) SCUmulti.TransComplete();

    // Perform non-local calculation for previous v
    if (v>0)
      if (v==1 && overwrite==1) {
	for(i=0; i<n_dir; i++)
	  if(non_local_chi[wire[i]]>0)
	    cross_over_lin(sum[i], &f, vect2[v-1],rcv_buf[wire[i]], hop*non_local_chi[wire[i]],
			   src_nl[hop-1][wire[i]], dest_nl[hop-1][wire[i]]);
      } else if (v%2==1) {
	for(i=0; i<n_dir; i++) 
	  if(non_local_chi[wire[i]]>0)
	    cross_lin(sum[i], &f, vect2[v-1],rcv_buf[wire[i]], hop*non_local_chi[wire[i]],
		      src_nl[hop-1][wire[i]], dest_nl[hop-1][wire[i]]);
      } else {
	for(i=0; i<n_dir; i++) 
	  if(non_local_chi[wire[i]]>0)
	    cross_lin(sum[i], &f,vect2[v-1],rcv_buf2[wire[i]], hop*non_local_chi[wire[i]],
		      src_nl[hop-1][wire[i]], dest_nl[hop-1][wire[i]]);
      }
    
    // Perform local calculation for current v
    if (v==0 && overwrite==1)
      {
	for(i=0; i<n_dir; i++)
	  if((vol-hop*non_local_chi[wire[i]])>0)
	    cross_over_look(sum[i], &f, vect2[v], vect[v][i], vol-hop*non_local_chi[wire[i]], src_l[hop-1][wire[i]], dest_l[hop-1][wire[i]]);
      }
    else
      {
	for(i=0; i<n_dir; i++)
	  if((vol-hop*non_local_chi[wire[i]])>0)
	    cross_look(sum[i], &f, vect2[v], vect[v][i], vol-hop*non_local_chi[wire[i]], src_l[hop-1][wire[i]], dest_l[hop-1][wire[i]]);
      }

  }

  if (v==1 && overwrite==1) {
    for(i=0; i<n_dir; i++) 
      if(non_local_chi[wire[i]]>0)
	cross_over_lin(sum[i], &f, vect2[v-1],rcv_buf[wire[i]], hop*non_local_chi[wire[i]],
		       src_nl[hop-1][wire[i]], dest_nl[hop-1][wire[i]]);
  } else if (v%2==1) {
    for(i=0; i<n_dir; i++)
      if(non_local_chi[wire[i]]>0)
	cross_lin(sum[i], &f, vect2[v-1],rcv_buf[wire[i]], hop*non_local_chi[wire[i]],
		  src_nl[hop-1][wire[i]], dest_nl[hop-1][wire[i]]);
  } else {
    for(i=0; i<n_dir; i++) 
      if(non_local_chi[wire[i]]>0)
	cross_lin(sum[i], &f,vect2[v-1],rcv_buf2[wire[i]], hop*non_local_chi[wire[i]],
		  src_nl[hop-1][wire[i]], dest_nl[hop-1][wire[i]]);
  }
  
  //  ParTrans::PTflops += 90*n_vect*n_dir*vol;
}

//! u[x] = v[x+dir] for n_dir forward or backward directions dir.
void PT::shift_field(IFloat **v, const int *dir, int n_dir,
		     int hop, IFloat **u){
  
  int i, length;
  int wire[n_dir];
  for (i=0; i<n_dir;i++) wire[i] = dir[i];
  SCUDirArgMulti SCUmulti;
  SCUDirArgIR *SCUarg_p[2*n_dir];
  
  int comms=0;
  for (i=0; i<n_dir; i++) 
  if (!local[wire[i]/2]){
    SCUarg_p[2*comms] = SCUarg_mat[hop-1][2*wire[i]];
    SCUarg_p[2*comms+1] = SCUarg_mat[hop-1][2*wire[i]+1];
    SCUarg_p[2*comms+1]->Addr((void *)(v[i]+GAUGE_LEN*set_offset(wire[i], hop)));
    comms++;
  }

  if (comms) SCUmulti.Init(SCUarg_p,2*comms);
  if (comms) SCUmulti.SlowStartTrans();
//  SCUmulti.TransComplete();
  
  for (i=0; i<n_dir; i++) {
    length = vol-hop*non_local_chi[wire[i]];
    copy_matrix(u[i],v[i],&length,dest_l[hop-1][wire[i]],
		src_l[hop-1][wire[i]]);
  }
  if (comms) SCUmulti.TransComplete();

  for (i=0; i<n_dir; i++) {
    length = hop*non_local_chi[wire[i]];
    copy_matrix(u[i],(IFloat*)rcv_buf[wire[i]],&length,
		dest_nl[hop-1][wire[i]],src_nl[hop-1][wire[i]]);
  }
}

//! u[x] = v[x+dir] for n_dir forward or backward directions dir for vector fields
void PT::shift_field_vec(IFloat **v, const int *dir, int n_dir,
		    int hop, IFloat **u){
  //printf("shift_field_vec() called\n");
  int i, length;
  int wire[n_dir];
  for (i=0; i<n_dir;i++) wire[i] = dir[i];
  SCUDirArgMulti SCUmulti;
  SCUDirArgIR *SCUarg_p[2*n_dir];
  
  int comms=0;
  for (i=0; i<n_dir; i++) 
  if (!local[wire[i]/2]){
    SCUarg_p[2*comms] = SCUarg[hop-1][2*wire[i]];
    SCUarg_p[2*comms+1] = SCUarg[hop-1][2*wire[i]+1];
    SCUarg_p[2*comms+1]->Addr((void *)(v[i]+VECT_LEN*set_offset(wire[i], hop)));
    comms++;
  }

  if (comms) SCUmulti.Init(SCUarg_p,2*comms);
  if (comms) SCUmulti.SlowStartTrans();
//  SCUmulti.TransComplete();
  
  for (i=0; i<n_dir; i++) {
    length = vol-hop*non_local_chi[wire[i]];
    copy_vector(u[i],v[i],&length,dest_l[hop-1][wire[i]],
		src_l[hop-1][wire[i]]);
  }
  if (comms) SCUmulti.TransComplete();

  for (i=0; i<n_dir; i++) {
    length = hop*non_local_chi[wire[i]];
    copy_vector(u[i],(IFloat*)rcv_buf[wire[i]],&length,
		dest_nl[hop-1][wire[i]],src_nl[hop-1][wire[i]]);
  }

}

//! u[-/+nu](x) = U_[-/+nu](x) 
void PT::shift_link(IFloat **u, const int *dir, int n_dir){

//  char *fname = "pt_shift_link()";
  int length;
  for (int i=0; i<n_dir; i++) {
    
    length = local_chi[dir[i]];
    copy_gauge(u[i],uc_l[dir[i]],&length,dest_l[0][dir[i]]);
    length = non_local_chi[dir[i]];
    copy_gauge(u[i],uc_nl[dir[i]],&length,dest_nl[0][dir[i]]);
    
  }

}

//CPS_END_NAMESPACE
